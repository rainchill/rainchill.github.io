{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/nprogress.js","path":"js/third-party/nprogress.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"a69026d144a7496fb319c7327850dee738de4f2c","modified":1649182636900},{"_id":"source/_posts/写给小白看的makefile教程.md","hash":"52821d5dd0ce35859f4f8e040f27e5238c40271a","modified":1649182636900},{"_id":"source/about/index.md","hash":"13432d3c4ea46fceea0923bcf1e3135ff1826fa0","modified":1649183849202},{"_id":"source/.DS_Store","hash":"3c3a1dcdeba7fe6fcb365c11f284216f2ca07af1","modified":1649183462167},{"_id":"source/_posts/linux-c-基本函数.md","hash":"76c737ec3c2a1c0be2d972dfe123fa566caad152","modified":1649182636900},{"_id":"source/categories/index.md","hash":"eb77548db8475bf9d6513757d43beccdb2d56fe8","modified":1649182636900},{"_id":"source/tags/index.md","hash":"6d7d7d8f1103b7d672a7d2689dad96b312f3323f","modified":1649182636901},{"_id":"source/images/avatar.jpg","hash":"d17d0b76f6cae63873b6fad8901a44271a41afd6","modified":1649182636897},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"eff30232f668f47d1f734fdd914fec0d18095817","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/package.json","hash":"ffb3ad2b9f030b8a675da07b4ef8fa3a816522c9","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/README.md","hash":"fab15a85d9d8d90ecd8879525b9b74fb1c197978","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"2924be391e4841e2166e83d4d18515c4d247653f","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1649182636671},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"2a9861db4547a524b2609c1e7e1061d2e9d48ee4","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"87edab5a3eb7577a409c01df3f1631de40f8956f","modified":1649182636669},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"99ab10d9aef1ee5ae5e8f3572ac0de25c3cc4416","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"42a9b81c5449afa9d67770604478168333c93804","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"454ed1fac07be972c7ec911092f0995cd925aab3","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"02bafc6ee86263790603861e356596f0c916e392","modified":1649182636670},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"a20ed899d6a797de0b35c46bfd03722023649187","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"13e7badc036e989307069f65b179deb107012435","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/nprogress.njk","hash":"80fd1a45e91207fc16df1136e12b8b71b4f65dea","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"5bfc1cea214bd31847adc356f37df8e0b6a449df","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"2ecaa30ec42d28ef769d875cf2d26959b8de7d24","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"92ab6bb3c3122980699f0613dac27a7cabfedecc","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1649182636677},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"49aa8de07918a11399131dfd703418af3f0a1a19","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"13b3301aa9b613975630502d93e6ae82c5293aa8","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"1084e38df2f05a2f58df7f987e660775e9be1bf2","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"cdf2a692baa5cd34104ffabced2c5ef608b62cf5","modified":1649182636685},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1649182636672},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"5c01e380ba843f8016d8fa4593432430f5bd3584","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1649182636673},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"3fc91aba5b17a5ae60b8e04707a7da87db4d0340","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1649182636676},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"32a1b73944561655087d80f025208a84e012b3cf","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/third-party/nprogress.js","hash":"7d56b18a2bdece5468470c70c5f3eb79d4120964","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1649182636674},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"ece860218125bdb2578f373ed4f5040c9670e4b1","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1649182636675},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"3c7ae405dd30b9b46494a6b9a6cb1b7ec6138ba9","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"aafbb3c5c20f525a92716d89ff216c3081d7b4da","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"41cba8c4c5637a6b8f1b62e67673b33676f5d734","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"2a29bf3692f42f84e8f29314e0fb349f86fc727a","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1649182636683},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"9771db8b6b2541181a0e463c4bf305276d47657d","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"b37f1b14aef2402d0c2d88f999ff0ce5ef6823c1","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"aafb764c64f6cd5a48ad194adf65ac77078242b1","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1649182636678},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"dbac7197ebffecf4bf32f8a3cddef434f17f2ca1","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1649182636684},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"bef7791a2e67e79f02076f2a89e1c7f95a83048c","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"b457756758f0632767e8a560e3033059cbe4a67b","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"7102f8e819b62cf7d121fd063dc663fd068feaa6","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1649182636682},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"83c6588c51cd418336f4945813410a100ddfe2a4","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"4f482514230c941c9475e1272188e53a54975463","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"d6d60f02b5e9f89dbfce180b3884030898022664","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"cf194bea1c9e67fde871a04de3bc81df72c54277","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"bf88d9c585d7b00463c46352402cfea415c29493","modified":1649182636679},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"eae7b83f1c711ad2ab3a41d89f517445856ffec8","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"6394340c28a21f6aa90e786f3bfe24fb26595653","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"69eb1c282a8fd5dbab606cc09c34c5dc8e44e753","modified":1649182636680},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"08e79881d58d01afab6dbed37ab4f52356564d7e","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"2421500e447822ef1b6826403a3e1df3345641d7","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"f53e6c12bd4805888f696386d00668f23cd335e7","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"50b00218e854200c4ec0573a841e226d49c45cba","modified":1649182636681},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1649182636681},{"_id":"public/sitemap.xml","hash":"ccb7075d9ba45b1361be4d8dc3a9f74f4fb27fd2","modified":1649448045919},{"_id":"public/tags/index.html","hash":"1364dfade02e57713eee37e6d1b7c91c17eac254","modified":1649448045919},{"_id":"public/categories/index.html","hash":"7e5222cdbc9a90b1ebbaf3170231b5d9192218a6","modified":1649448045919},{"_id":"public/about/index.html","hash":"90d15b9e790e2e18a024b0a1c8d578d93a8abfdd","modified":1649448045919},{"_id":"public/categories/linux学习/index.html","hash":"eaab24e06087a506192427225072993c2d13f882","modified":1649448045919},{"_id":"public/index.html","hash":"690c7cad52b1747dfe36c8f522ee05e786cb9261","modified":1649448782362},{"_id":"public/tags/linux/index.html","hash":"318dc274f3ff3e45da299e2f992ea52b696b4959","modified":1649448045919},{"_id":"public/tags/c/index.html","hash":"7d43a4917a73447f056f7a52dd92e3109e6dc7a7","modified":1649448045919},{"_id":"public/tags/makefile/index.html","hash":"0f1a5586ba7f03f2d9e58b1d9175e112bb344e15","modified":1649448045919},{"_id":"public/archives/index.html","hash":"41c0cb08e313f61423d576371a1bde566894524f","modified":1649448212263},{"_id":"public/archives/2021/index.html","hash":"d67db0921de3d00f46a6b285fb2c10bc3f503b16","modified":1649448045919},{"_id":"public/archives/2021/08/index.html","hash":"4e3ee36f3638062504f2ea44786d26b56f1b5190","modified":1649448045919},{"_id":"public/2021/08/16/linux-c-基本函数/index.html","hash":"f6b291290bc22813f9bece0a07dae5c43e894687","modified":1649448212263},{"_id":"public/2021/08/11/写给小白看的makefile教程/index.html","hash":"6ee5ca2a755a5db4e7d1e6ccc1a22d8e8a9af5ae","modified":1649448045919},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1649183868787},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1649183868787},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1649183868787},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1649183868787},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1649183868787},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1649183868787},{"_id":"public/CNAME","hash":"a69026d144a7496fb319c7327850dee738de4f2c","modified":1649183868787},{"_id":"public/images/avatar.jpg","hash":"d17d0b76f6cae63873b6fad8901a44271a41afd6","modified":1649183868787},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1649183868787},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1649183868787},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1649183868787},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1649183868787},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1649183868787},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1649183868787},{"_id":"public/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1649183868787},{"_id":"public/js/next-boot.js","hash":"2ecaa30ec42d28ef769d875cf2d26959b8de7d24","modified":1649183868787},{"_id":"public/js/utils.js","hash":"cdf2a692baa5cd34104ffabced2c5ef608b62cf5","modified":1649183868787},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1649183868787},{"_id":"public/js/third-party/nprogress.js","hash":"7d56b18a2bdece5468470c70c5f3eb79d4120964","modified":1649183868787},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1649183868787},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1649183868787},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1649183868787},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1649183868787},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1649183868787},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1649183868787},{"_id":"public/js/pjax.js","hash":"5bfc1cea214bd31847adc356f37df8e0b6a449df","modified":1649183868787},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1649183868787},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1649183868787},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1649183868787},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1649183868787},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1649183868787},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1649183868787},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1649183868787},{"_id":"public/js/third-party/search/local-search.js","hash":"b37f1b14aef2402d0c2d88f999ff0ce5ef6823c1","modified":1649183868787},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1649183868787},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1649183868787},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1649183868787},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1649183868787},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1649183868787},{"_id":"public/js/third-party/math/mathjax.js","hash":"9771db8b6b2541181a0e463c4bf305276d47657d","modified":1649183868787},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1649183868787},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1649183868787},{"_id":"public/js/third-party/tags/mermaid.js","hash":"aafb764c64f6cd5a48ad194adf65ac77078242b1","modified":1649183868787},{"_id":"public/css/main.css","hash":"74b5896a668aa7e0b4d44ba98e05d2e2346f9f9b","modified":1649183868787},{"_id":"source/_posts/vlan-技术学习总结.md","hash":"fca9089e6e64a0c2cadbc5fb35bd6f1115b516c1","modified":1649448768099},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1649447962959},{"_id":"public/archives/2022/index.html","hash":"b97696ad10363b94654b8aa5a23aa110207f87ec","modified":1649448212263},{"_id":"public/archives/2022/04/index.html","hash":"16cc2e66b5827060ef76303cf56b8fa5be5c7da9","modified":1649448212263},{"_id":"public/2022/04/09/vlan-技术学习总结/index.html","hash":"460d296e1dc5c57ec56ee27f7707aebcdc60796a","modified":1649448782362}],"Category":[{"name":"linux学习","_id":"cl1mhhtd200049icb7x6ielyd"}],"Data":[],"Page":[{"title":"标签","date":"2021-08-15T12:00:08.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-08-15 12:00:08\ntype: tags\n---\n","updated":"2022-04-05T18:17:16.901Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl1mhhtcy00009icb26bw9d2y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2021-08-14T22:17:41.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-08-14 22:17:41\ntype: categories\n---\n","updated":"2022-04-05T18:17:16.900Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl1mhhtd100029icb47axag07","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2021-08-14T22:20:03.000Z","_content":"\n404 Not Found.\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-08-14 22:20:03\n---\n\n404 Not Found.\n","updated":"2022-04-05T18:37:29.202Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl1mhhtd300069icbepyycmj5","content":"<p>404 Not Found.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>404 Not Found.</p>\n"}],"Post":[{"title":"linux c 基本函数","date":"2021-08-15T16:55:07.000Z","_content":"\n## open\n\n### 函数原型\n\n```c\n #include <fcntl.h>\n\n       int open(const char *pathname, int flags);\n       int open(const char *pathname, int flags, mode_t mode);\n```\n\n<!--more-->\n\nopen 函数可以打开 pathname 指定的文件，如果这个指定的文件不存在，可以选择创建它（前提是 O_CREAT 在 flags 中指定了），而指定了 O_CREAT 后需要指定第三个参数 mode 。\n\n其中 flags 定义的宏在 fcntl.h 头文件中。\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_CREAT, 0644);\n```\n\n该语句打开当前目录下的 yuhan.txt 文件，指定打开的权限是可读可写，如果该文件不存在则创建它，创建该文件的权限为 rw-r--r--。\n\n前面加0，0644代表八进制数。\n\n**如果不创建：**\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR);\n```\n\n---\n\n### 返回值\n\n该函数返回一个 int 类型的文件描述符（非负整数），搭配 read、write 等函数使用。\n\n成功调用的返回值是当前未被进程打开的最小的可用的文件描述符。\n\n**如果失败：**\n\n返回 -1 并且设置 errno , errno 是被系统创建的一个用来标识错误的变量，用 perror 输出错误。\n\n### 其它描述\n\n- 默认的该函数返回的文件描述符所打开的文件处于始终打开的状态，可以用 close 函数关闭。\n\n- 参数 flags 必须包含 **O_RDONLY、O_WRONLY、O_RDWR** 中的一个。\n\n- O_TRUNC 覆盖写\n\n比如：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_CREAT | O_TRUNC , 0644);\n```\n\n- O_APPEND 追加写\n- 创建文件 creat 可以用 open 实现，使用 flags ： O_CREAT|O_WRONLY|O_TRUNC \n\n比较重要的大概就这一些。\n\n## read\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       ssize_t read(int fd, void *buf, size_t count);\n```\n\nread 函数通过文件描述符 fd 读取 count 字节大小的内容到 buf 缓冲区中\n\n---\n\n举例：\n\n```c\n    char buf[1024];\n    // yuhan.txt: <hello i'am yuhanOvo>\n    int fd = open(\"yuhan.txt\", O_RDWR);\n    while(read(fd, buf, 1024)) {\n        printf(\" buf: %s\", buf);\n    }\n\n// >> buf: hello i am yuhanOvo\n```\n\n### 返回值\n\n调用成功时，返回读取的字节数（为0时，则表示读到了文件结尾）。并且，下次读取文件的位置被偏移了返回值的大小个字节。也就是第二次 read 会从第一次 read 的结尾处继续读取。\n\n如果返回的值小于请求的参数 count ， 这不是一个错误，因为剩余可读取的字节数小于 count 的大小是完全有可能的。*或者我们可能在一个管道上读取。其它原因不展开。\n\n调用失败时，返回 -1 ，并且系统会设置 errno 来指示错误。\n\n比如：\n\n```c\nn = read(1000, buf, 1024);\n    if(n == -1) {\n        perror(\"read error\");\n    }\n\n// >> read error: Bad file descriptor\n```\n\n### 其它描述\n\n关于 count 的大小选取，如果比 SSIZE_MAX 大，结果未定义。\n\n## write\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       ssize_t write(int fd, const void *buf, size_t count);\n```\n\nwrite 函数从缓冲区 buf 中读取 count 字节的内容写入文件描述符 fd 所指向的文件中。\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_TRUNC);\nchar *hello = \"hello world\";\nwrite(fd, hello, strlen(hello));\n```\n\n### 返回值\n\n调用成功时，返回写入的字节数。\n\n调用失败时，返回 -1，并设置 errno 。\n\n**注意：**\n\n返回的字节数可能小于 count 的大小，可能的原因之一是写入的硬件磁盘的容量不够。\n\n### 其它描述\n\n暂无\n\n## fcntl\n\n### 函数原型\n\n```c\n#include <fcntl.h>\n\n       int fcntl(int fd, int cmd, ... /* arg */ );\n```\n\nfcntl 函数用来控制文件描述符\n\ncmd 可以是各种被设置好的宏，当 cmd 表示为不同的宏时 fcntl 具有不同的功能。\n\n#### 复制描述符\n\nF_DUPFD (int类型)\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_TRUNC);\nint fd2 = fcntl(fd, F_DUPFD, 0);\n```\n\n此时 fd2 和 fd 所指向的文件相同。\n\n注意第三个参数 0 ，代表返回一个大于等于 0 的可用的文件描述符。\n\n\n\n这个函数还不太熟悉。\n\n## lseek - 定位读/写文件偏移量\n\n参考： https://man7.org/linux/man-pages/man2/lseek.2.html\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       off_t lseek(int fd, off_t offset, int whence);\n```\n\n定位读或者写文件的偏移量。\n\n### 描述\n\nlseek 函数根据偏移量 *offset* 和偏移模式 *whence* 来定位 *fd* 所关联文件的偏移位置。 \n\n####　whence 参数\n\nSEEK_SET：  从文件开始的位置偏移 *offset* 个偏移量\n\nSEEK_CUR：  从文件指针当前挪到的位置偏移 *offset* 个偏移量\n\nSEEK_END： 从文件结尾的位置偏移 *offset* 个偏移量\n\n---\n\n*offset* 可以是负数， 表示向左偏移。\n\nlseek 函数允许偏移量设置在文件的结尾之后，但是这将不会改变文件的大小，只有在偏移之后再写入数据到文件之后，那些偏移了但是还没有填入数据的位置为一个空洞（'\\0'）。\n\n### 返回值\n\n成功时，返回从文件开头到所偏移到的位置一共的偏移量（以字节为单位）。\n\n失败时，返回 -1， 设置 errno。\n\n###　一些用处\n\n拓展文件大小：\n\n```c\nint fd = open(\"txt\", O_RDWR | O_CREAT, 0644);\nlseek(fd, 100, SEEK_SET);\nwrite(fd, \"\\0\", 1);\n```\n\n此文件大小为 101个字节。\n\n其它方式还有：\n\nftruncate() \n\n```c\n       #include <unistd.h>\n\n       int truncate(const char *path, off_t length);\n       int ftruncate(int fd, off_t length);\n```\n\nftruncate(fd, 100);\n\n## dup, dup2, dup3 - 复制一个文件描述符\n\n参考： https://man7.org/linux/man-pages/man2/dup.2.html\n\n### 函数原型\n\n```c\n       #include <unistd.h>\n\n       int dup(int oldfd);\n       int dup2(int oldfd, int newfd);\n\n       #define _GNU_SOURCE             /* See feature_test_macros(7) */\n       #include <fcntl.h>              /* Definition of O_* constants */\n       #include <unistd.h>\n\n       int dup3(int oldfd, int newfd, int flags);\n```\n\n---\n\n举例：\n\ndup() :\n\n```c\nint fd = open(\"txt\", O_RDWR);\nint new_fd = dup(fd);\nwrite(new_fd, \"x\", 1);\n```\n\ndup2() :\n\n```c\nint fd = open(\"txt\", O_RDWR);\ndup2(fd, STDOUT_FILENO);\nprintf(\"HELLO WORLD\");\n```\n\n![image-20210821195326502](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210821195326502.1h80zd76196o.png)\n\n### 描述\n\n暂无\n\n### 返回值\n\n成功时，这些系统调用将返回新的文件描述符。\n\n失败时，返回 -1， 设置 errno。\n\n## fork - 创建一个子进程\n\n参考：https://man7.org/linux/man-pages/man2/fork.2.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       pid_t fork(void);\n```\n\nfork函数用来创建一个子进程。\n\n![image-20210817145349164](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210817145349164.3vfbf8e1tka0.png)\n\n---\n\n举例：\n\n```c\n    printf(\"start fork()\\n\");\n    pid_t pid = fork();\n\n    if(pid == -1) {\n        perror(\"fork error\\n\");\n        return 0;\n    } else if(pid == 0) {\n        printf(\"child process\\n\");\n    } else if(pid > 0) {\n        printf(\"parent process\\n\");\n    }\n    printf(\"end\\n\");\n\n/*\n>>  start fork()\n    parent process\n    end\n    child process\n    end\n*/\n```\n\n### 描述\n\nfork() 函数通过重复调用进程创建一个新的进程，这个新的进程被称为子进程，调用 fork() 的进程被称为父进程。子进程和父进程在独立的内存空间中运行。在 fork() 时，两块内存空间具有相同的内容。\n\n子进程与父进程完全相同，除了一下几点：\n\n- 子进程有它独特的进程 ID\n- 子进程的父进程ID与父进程ID相同。\n\n等等\n\n### 返回值\n\n成功时，在父进程中，返回子进程的 PID；在子进程中，返回0。\n\n失败时，父进程中返回 -1，并且没有子进程被创建。并且，errno 被设置。\n\n## getpid, getppid - 获取进程标识\n\n参考：https://man7.org/linux/man-pages/man2/getpid.2.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       pid_t getpid(void);\n       pid_t getppid(void);\n```\n\n### 描述\n\ngetpid() 返回该进程的 ID（PID）。\n\ngetppid() 返回该进程的父进程的 ID。\n\n## exec系列 - 执行一个文件\n\n参考：https://man7.org/linux/man-pages/man3/exec.3.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       extern char **environ;\n\n       int execl(const char *pathname, const char *arg, ...\n                       /*, (char *) NULL */);\n       int execlp(const char *file, const char *arg, ...\n                       /*, (char *) NULL */);\n       int execle(const char *pathname, const char *arg, ...\n                       /*, (char *) NULL, char *const envp[] */);\n       int execv(const char *pathname, char *const argv[]);\n       int execvp(const char *file, char *const argv[]);\n       int execvpe(const char *file, char *const argv[], char *const envp[]);\n```\n\n可以按照函数名的后缀对其进行分类：\n\n#### l - execl(), execlp(), execle()\n\n这三个函数有一个共同的参数 const char *arg，这个const char *arg和后面的省略号可以看成 arg0，arg1，arg2 ... ... argn。这些参数构成了执行程序的参数列表。第一个参数 const char *file/pathname，约定俗成，应该指向正在执行的文件的文件名。\n\n后面的参数列表必须以空指针 NULL 结尾，用来告诉这个可变参数的函数这已经是最后一个参数了。\n\n除此之外，参数列表的第一个参数 arg0 也必须是执行的文件名。拿execlp举例来说，execlp根据环境变量中的路径找到pathname所指向的文件名，然后执行该文件，执行该文件的 argv[0]，argv[1]，... ，argv[n] 与参数列表中 arg0，arg1，arg2 ... ... argn 相对应，而argv[0] 正是当前执行的文件名，也就是说，除了第一个参数 const char *file/pathname 要指定文件名，第二个参数 arg0 也需要指定文件名。\n\n---\n\n举例：\n\n```c\nexeclp(\"ls\", \"ls\", \"-l\", NULL);\nexecl(\"../forkProcess/out/fork\", NULL);\n// ----------------------------------------\nexeclp(\"date\", \"date\", NULL);\nexecl(\"/usr/bin/date\", \"date\", NULL);\nexecle(\"/usr/bin/date\", \"date\", NULL, NULL);\n```\n\n#### v - execv(), execvp(), execvpe()\n\n#### e - execle(), execvpe()\n\n#### p - execlp(), execvp(), execvpe()\n\n### 描述\n\nexec() 系列函数用一个新的进程映像替换当前进程映像。也就是说当前进程的 PID 和其父进程都没有改变，而该进程所执行的东西已经变为了 exec 所执行的文件。\n\n该系列的函数是在 execve 函数的基础上是实现的。execve 函数参考：https://man7.org/linux/man-pages/man2/execve.2.html\n\n### 返回值\n\nexec() 系列函数仅在发生错误时返回 -1，并设置 errno。\n\n## wait, waitpid, waitid - 等待进程改变状态\n\n参考：https://man7.org/linux/man-pages/man2/waitpid.2.html\n\n### 函数原型\n\n```c\n#include <sys/wait.h>\n\n       pid_t wait(int *wstatus);\n       pid_t waitpid(pid_t pid, int *wstatus, int options);\n\n       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n                       /* 这是glibc和POSIX接口;有关原始系统调用的信息，请参阅NOTES。 */\n```\n\n### 描述\n\n所有这些 **系统调用** 都是用来等待正在进行的子进程的状态发生变化的，并且获取到子进程状态发生变化的具体信息。\n\n**状态改变** 可以被认为是：\n\n- 子进程终止\n- 子进程被一个信号中断了\n- 子进程被一个信号恢复了\n\n在子进程结束的情况下，父进程执行等待可以有效释放子进程的系统资源，如果没有执行等待，那么结束的子进程将以一个“僵尸”状态继续被保留。\n\n如果一个子进程改变了状态，这些调用将立即返回，否则，它们会阻塞，直到子进程改变状态或信号处理程序中断调用。\n\n#### wait 和 waitpid\n\nwait() **系统调用** 将暂停调用线程的执行，直到它的一个子线程终止。\n\n函数调用  *wait(int \\*wstatus)*  等同于：\n\n```c\nwaitpid(-1, &wstatus, 0);\n```\n\nwaitpid **系统调用** 挂起当前调用线程，直到由 *pid* 参数指定的子进程发生变化。默认情况下，waitpid 只等待终止的子进程，但此行为可以通过修改参数 *options* 改变。\n\n##### pid 参数\n\n*pid* 的值可以是：\n\n- < -1 　　　　意思是等待任何*进程组 ID 等于 pid 绝对值的子进程\n- -1 　　　　　意思是任何子进程\n- 0 　　　　　意思是等待任何进程组 ID 等于该调用 waitpid 的进程的进程组 ID 的子进程\n- \\> 0 　　　　意思是等待进程 ID 等于 pid 的子进程\n\n##### options 参数\n\n*options* 是一个组合值，包含 0 个或多个一下值：\n\nWNOHANG： 如果没有孩子死亡则立即返回\n\nWUNTRACED：\n\n。。。\n\n### 返回值\n\n##　pipe, pipe2 - 创建管道（进程间通信）\n\n参考： https://man7.org/linux/man-pages/man2/pipe.2.html\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       int pipe(int pipefd[2]);\n\n#define _GNU_SOURCE             /* See feature_test_macros(7) */\n#include <fcntl.h>              /* Definition of O_* constants */\n#include <unistd.h>\n\n       int pipe2(int pipefd[2], int flags);\n```\n\n---\n\n举例：\n\n```c\nint fd[2];\nint x = pipe(fd);    // 先\nint pid = fork();    // 后\n\nchar buf[1024];\nchar * str = \"hello world\";\nif(x == -1) {\n    perror(\"error\");\n    exit(1);\n}\n\nif(pid > 0) {\n    printf(\"i'm parent\\n\");\n    write(fd[1], str, strlen(str));\n} else if(pid == 0) {\n    printf(\"i am child\\n\");\n    int ret = read(fd[0], buf, 1024);\n    write(STDOUT_FILENO, buf, ret);\n}\n```\n\n### 描述\n\npipe() 创建一个 **单向** 的可以用于进程间通信的数据通道。 *pipefd[]* 用来返回两个分别指向管道入端和出端的文件描述符。  *pipefd[0]* 指的是管道的读端， *pipefd[1]* 为写端。写入写端的数据会被内核缓冲，直到从读端读取数据，写入的数据只能被读取一次，不能重复读取。  \n\n### 返回值\n\n成功时，返回 0\n\n失败时，返回 -1，设置 errno，并且 *pipefd* 不会被改变。\n\n## mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）\n\n参考： https://man7.org/linux/man-pages/man2/mmap.2.html\n\n### 函数原型\n\n```c\n   #include <sys/mman.h>\n\n   void *mmap(void *addr, size_t length, int prot, int flags,\n              int fd, off_t offset);\n   int munmap(void *addr, size_t length);\n```\n\n---\n\n举例：\n\n\n\n\n\n### 描述\n\nmmap() 在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址子在 *addr* 中指定。 *length* 指定映射的大小（必须大于0）。如果 *addr* 为NULL，那么内核选择(页面对齐的)地址来创建映射。这种方式创建的 mmap() 具有最好的可移植性。如果 *addr* 不为NULL，那么内核将其作为放置映射的位置的提示。 *offset* 必须是内存页（page size = 4096）的整数倍，可以通过 sysconf(_SC_PAGE_SIZE) 的返回值查看。\n\n文件映射的内容，初始化时使用从文件描述符 *fd* 引用的文件(或其他对象)的偏移量 *offset* 处开始的 *length* 字节大小的映射空间。\n\n![image-20210822022207629](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210822022207629.41lugd2750u0.png)\n\n#### prot 参数\n\n*prot* 指定映射的内存保护权限。有下面几个宏：\n\n- PROT_EXEC：映射的内存页可以执行\n- PROT_READ：映射的内存页可以读\n- PROT_WRITE：映射的内存页可以写\n- PROT_NONE：映射的内存页不可访问\n\n可以组合，比如 PROT_READ | PROT_WRITE 。\n\n#### flag 参数\n\n*flags* 参数确定对映射的更新是否对映射同一区域的其他进程可见，以及是否对底层文件进行更新。\n\n此行为由包含以下值之一确定：\n\n- MAP_SHARED： 分享这个映射。映射的更新对映射同一区域的其它进程是可见的。*并且(在文件支持映射的情况下)将被传递到底层文件。\n- MAP_PRIVATE： 创建私有的 **写时拷贝** 映射。\n\n还能由以下值的零个或多个确定：\n\n- MAP_32BIT\n- MAP_ANON\n\n。。。\n\n### 返回值\n\nmmap() :\n\n成功时，返回一个指向映射区域的指针。\n\n失败时，值 MAP_FAILED （类型为 （void *）-1 ），并设置 errno。\n\nmunmap()：\n","source":"_posts/linux-c-基本函数.md","raw":"---\ntitle: linux c 基本函数\ndate: 2021-08-15 16:55:07\ncategories: \n  - linux学习\ntags:\n  - linux\n  - c\n---\n\n## open\n\n### 函数原型\n\n```c\n #include <fcntl.h>\n\n       int open(const char *pathname, int flags);\n       int open(const char *pathname, int flags, mode_t mode);\n```\n\n<!--more-->\n\nopen 函数可以打开 pathname 指定的文件，如果这个指定的文件不存在，可以选择创建它（前提是 O_CREAT 在 flags 中指定了），而指定了 O_CREAT 后需要指定第三个参数 mode 。\n\n其中 flags 定义的宏在 fcntl.h 头文件中。\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_CREAT, 0644);\n```\n\n该语句打开当前目录下的 yuhan.txt 文件，指定打开的权限是可读可写，如果该文件不存在则创建它，创建该文件的权限为 rw-r--r--。\n\n前面加0，0644代表八进制数。\n\n**如果不创建：**\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR);\n```\n\n---\n\n### 返回值\n\n该函数返回一个 int 类型的文件描述符（非负整数），搭配 read、write 等函数使用。\n\n成功调用的返回值是当前未被进程打开的最小的可用的文件描述符。\n\n**如果失败：**\n\n返回 -1 并且设置 errno , errno 是被系统创建的一个用来标识错误的变量，用 perror 输出错误。\n\n### 其它描述\n\n- 默认的该函数返回的文件描述符所打开的文件处于始终打开的状态，可以用 close 函数关闭。\n\n- 参数 flags 必须包含 **O_RDONLY、O_WRONLY、O_RDWR** 中的一个。\n\n- O_TRUNC 覆盖写\n\n比如：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_CREAT | O_TRUNC , 0644);\n```\n\n- O_APPEND 追加写\n- 创建文件 creat 可以用 open 实现，使用 flags ： O_CREAT|O_WRONLY|O_TRUNC \n\n比较重要的大概就这一些。\n\n## read\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       ssize_t read(int fd, void *buf, size_t count);\n```\n\nread 函数通过文件描述符 fd 读取 count 字节大小的内容到 buf 缓冲区中\n\n---\n\n举例：\n\n```c\n    char buf[1024];\n    // yuhan.txt: <hello i'am yuhanOvo>\n    int fd = open(\"yuhan.txt\", O_RDWR);\n    while(read(fd, buf, 1024)) {\n        printf(\" buf: %s\", buf);\n    }\n\n// >> buf: hello i am yuhanOvo\n```\n\n### 返回值\n\n调用成功时，返回读取的字节数（为0时，则表示读到了文件结尾）。并且，下次读取文件的位置被偏移了返回值的大小个字节。也就是第二次 read 会从第一次 read 的结尾处继续读取。\n\n如果返回的值小于请求的参数 count ， 这不是一个错误，因为剩余可读取的字节数小于 count 的大小是完全有可能的。*或者我们可能在一个管道上读取。其它原因不展开。\n\n调用失败时，返回 -1 ，并且系统会设置 errno 来指示错误。\n\n比如：\n\n```c\nn = read(1000, buf, 1024);\n    if(n == -1) {\n        perror(\"read error\");\n    }\n\n// >> read error: Bad file descriptor\n```\n\n### 其它描述\n\n关于 count 的大小选取，如果比 SSIZE_MAX 大，结果未定义。\n\n## write\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       ssize_t write(int fd, const void *buf, size_t count);\n```\n\nwrite 函数从缓冲区 buf 中读取 count 字节的内容写入文件描述符 fd 所指向的文件中。\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_TRUNC);\nchar *hello = \"hello world\";\nwrite(fd, hello, strlen(hello));\n```\n\n### 返回值\n\n调用成功时，返回写入的字节数。\n\n调用失败时，返回 -1，并设置 errno 。\n\n**注意：**\n\n返回的字节数可能小于 count 的大小，可能的原因之一是写入的硬件磁盘的容量不够。\n\n### 其它描述\n\n暂无\n\n## fcntl\n\n### 函数原型\n\n```c\n#include <fcntl.h>\n\n       int fcntl(int fd, int cmd, ... /* arg */ );\n```\n\nfcntl 函数用来控制文件描述符\n\ncmd 可以是各种被设置好的宏，当 cmd 表示为不同的宏时 fcntl 具有不同的功能。\n\n#### 复制描述符\n\nF_DUPFD (int类型)\n\n---\n\n举例：\n\n```c\nint fd = open(\"yuhan.txt\", O_RDWR | O_TRUNC);\nint fd2 = fcntl(fd, F_DUPFD, 0);\n```\n\n此时 fd2 和 fd 所指向的文件相同。\n\n注意第三个参数 0 ，代表返回一个大于等于 0 的可用的文件描述符。\n\n\n\n这个函数还不太熟悉。\n\n## lseek - 定位读/写文件偏移量\n\n参考： https://man7.org/linux/man-pages/man2/lseek.2.html\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       off_t lseek(int fd, off_t offset, int whence);\n```\n\n定位读或者写文件的偏移量。\n\n### 描述\n\nlseek 函数根据偏移量 *offset* 和偏移模式 *whence* 来定位 *fd* 所关联文件的偏移位置。 \n\n####　whence 参数\n\nSEEK_SET：  从文件开始的位置偏移 *offset* 个偏移量\n\nSEEK_CUR：  从文件指针当前挪到的位置偏移 *offset* 个偏移量\n\nSEEK_END： 从文件结尾的位置偏移 *offset* 个偏移量\n\n---\n\n*offset* 可以是负数， 表示向左偏移。\n\nlseek 函数允许偏移量设置在文件的结尾之后，但是这将不会改变文件的大小，只有在偏移之后再写入数据到文件之后，那些偏移了但是还没有填入数据的位置为一个空洞（'\\0'）。\n\n### 返回值\n\n成功时，返回从文件开头到所偏移到的位置一共的偏移量（以字节为单位）。\n\n失败时，返回 -1， 设置 errno。\n\n###　一些用处\n\n拓展文件大小：\n\n```c\nint fd = open(\"txt\", O_RDWR | O_CREAT, 0644);\nlseek(fd, 100, SEEK_SET);\nwrite(fd, \"\\0\", 1);\n```\n\n此文件大小为 101个字节。\n\n其它方式还有：\n\nftruncate() \n\n```c\n       #include <unistd.h>\n\n       int truncate(const char *path, off_t length);\n       int ftruncate(int fd, off_t length);\n```\n\nftruncate(fd, 100);\n\n## dup, dup2, dup3 - 复制一个文件描述符\n\n参考： https://man7.org/linux/man-pages/man2/dup.2.html\n\n### 函数原型\n\n```c\n       #include <unistd.h>\n\n       int dup(int oldfd);\n       int dup2(int oldfd, int newfd);\n\n       #define _GNU_SOURCE             /* See feature_test_macros(7) */\n       #include <fcntl.h>              /* Definition of O_* constants */\n       #include <unistd.h>\n\n       int dup3(int oldfd, int newfd, int flags);\n```\n\n---\n\n举例：\n\ndup() :\n\n```c\nint fd = open(\"txt\", O_RDWR);\nint new_fd = dup(fd);\nwrite(new_fd, \"x\", 1);\n```\n\ndup2() :\n\n```c\nint fd = open(\"txt\", O_RDWR);\ndup2(fd, STDOUT_FILENO);\nprintf(\"HELLO WORLD\");\n```\n\n![image-20210821195326502](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210821195326502.1h80zd76196o.png)\n\n### 描述\n\n暂无\n\n### 返回值\n\n成功时，这些系统调用将返回新的文件描述符。\n\n失败时，返回 -1， 设置 errno。\n\n## fork - 创建一个子进程\n\n参考：https://man7.org/linux/man-pages/man2/fork.2.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       pid_t fork(void);\n```\n\nfork函数用来创建一个子进程。\n\n![image-20210817145349164](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210817145349164.3vfbf8e1tka0.png)\n\n---\n\n举例：\n\n```c\n    printf(\"start fork()\\n\");\n    pid_t pid = fork();\n\n    if(pid == -1) {\n        perror(\"fork error\\n\");\n        return 0;\n    } else if(pid == 0) {\n        printf(\"child process\\n\");\n    } else if(pid > 0) {\n        printf(\"parent process\\n\");\n    }\n    printf(\"end\\n\");\n\n/*\n>>  start fork()\n    parent process\n    end\n    child process\n    end\n*/\n```\n\n### 描述\n\nfork() 函数通过重复调用进程创建一个新的进程，这个新的进程被称为子进程，调用 fork() 的进程被称为父进程。子进程和父进程在独立的内存空间中运行。在 fork() 时，两块内存空间具有相同的内容。\n\n子进程与父进程完全相同，除了一下几点：\n\n- 子进程有它独特的进程 ID\n- 子进程的父进程ID与父进程ID相同。\n\n等等\n\n### 返回值\n\n成功时，在父进程中，返回子进程的 PID；在子进程中，返回0。\n\n失败时，父进程中返回 -1，并且没有子进程被创建。并且，errno 被设置。\n\n## getpid, getppid - 获取进程标识\n\n参考：https://man7.org/linux/man-pages/man2/getpid.2.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       pid_t getpid(void);\n       pid_t getppid(void);\n```\n\n### 描述\n\ngetpid() 返回该进程的 ID（PID）。\n\ngetppid() 返回该进程的父进程的 ID。\n\n## exec系列 - 执行一个文件\n\n参考：https://man7.org/linux/man-pages/man3/exec.3.html\n\n### 函数原型\n\n```c\n#include <unistd.h>\n\n       extern char **environ;\n\n       int execl(const char *pathname, const char *arg, ...\n                       /*, (char *) NULL */);\n       int execlp(const char *file, const char *arg, ...\n                       /*, (char *) NULL */);\n       int execle(const char *pathname, const char *arg, ...\n                       /*, (char *) NULL, char *const envp[] */);\n       int execv(const char *pathname, char *const argv[]);\n       int execvp(const char *file, char *const argv[]);\n       int execvpe(const char *file, char *const argv[], char *const envp[]);\n```\n\n可以按照函数名的后缀对其进行分类：\n\n#### l - execl(), execlp(), execle()\n\n这三个函数有一个共同的参数 const char *arg，这个const char *arg和后面的省略号可以看成 arg0，arg1，arg2 ... ... argn。这些参数构成了执行程序的参数列表。第一个参数 const char *file/pathname，约定俗成，应该指向正在执行的文件的文件名。\n\n后面的参数列表必须以空指针 NULL 结尾，用来告诉这个可变参数的函数这已经是最后一个参数了。\n\n除此之外，参数列表的第一个参数 arg0 也必须是执行的文件名。拿execlp举例来说，execlp根据环境变量中的路径找到pathname所指向的文件名，然后执行该文件，执行该文件的 argv[0]，argv[1]，... ，argv[n] 与参数列表中 arg0，arg1，arg2 ... ... argn 相对应，而argv[0] 正是当前执行的文件名，也就是说，除了第一个参数 const char *file/pathname 要指定文件名，第二个参数 arg0 也需要指定文件名。\n\n---\n\n举例：\n\n```c\nexeclp(\"ls\", \"ls\", \"-l\", NULL);\nexecl(\"../forkProcess/out/fork\", NULL);\n// ----------------------------------------\nexeclp(\"date\", \"date\", NULL);\nexecl(\"/usr/bin/date\", \"date\", NULL);\nexecle(\"/usr/bin/date\", \"date\", NULL, NULL);\n```\n\n#### v - execv(), execvp(), execvpe()\n\n#### e - execle(), execvpe()\n\n#### p - execlp(), execvp(), execvpe()\n\n### 描述\n\nexec() 系列函数用一个新的进程映像替换当前进程映像。也就是说当前进程的 PID 和其父进程都没有改变，而该进程所执行的东西已经变为了 exec 所执行的文件。\n\n该系列的函数是在 execve 函数的基础上是实现的。execve 函数参考：https://man7.org/linux/man-pages/man2/execve.2.html\n\n### 返回值\n\nexec() 系列函数仅在发生错误时返回 -1，并设置 errno。\n\n## wait, waitpid, waitid - 等待进程改变状态\n\n参考：https://man7.org/linux/man-pages/man2/waitpid.2.html\n\n### 函数原型\n\n```c\n#include <sys/wait.h>\n\n       pid_t wait(int *wstatus);\n       pid_t waitpid(pid_t pid, int *wstatus, int options);\n\n       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n                       /* 这是glibc和POSIX接口;有关原始系统调用的信息，请参阅NOTES。 */\n```\n\n### 描述\n\n所有这些 **系统调用** 都是用来等待正在进行的子进程的状态发生变化的，并且获取到子进程状态发生变化的具体信息。\n\n**状态改变** 可以被认为是：\n\n- 子进程终止\n- 子进程被一个信号中断了\n- 子进程被一个信号恢复了\n\n在子进程结束的情况下，父进程执行等待可以有效释放子进程的系统资源，如果没有执行等待，那么结束的子进程将以一个“僵尸”状态继续被保留。\n\n如果一个子进程改变了状态，这些调用将立即返回，否则，它们会阻塞，直到子进程改变状态或信号处理程序中断调用。\n\n#### wait 和 waitpid\n\nwait() **系统调用** 将暂停调用线程的执行，直到它的一个子线程终止。\n\n函数调用  *wait(int \\*wstatus)*  等同于：\n\n```c\nwaitpid(-1, &wstatus, 0);\n```\n\nwaitpid **系统调用** 挂起当前调用线程，直到由 *pid* 参数指定的子进程发生变化。默认情况下，waitpid 只等待终止的子进程，但此行为可以通过修改参数 *options* 改变。\n\n##### pid 参数\n\n*pid* 的值可以是：\n\n- < -1 　　　　意思是等待任何*进程组 ID 等于 pid 绝对值的子进程\n- -1 　　　　　意思是任何子进程\n- 0 　　　　　意思是等待任何进程组 ID 等于该调用 waitpid 的进程的进程组 ID 的子进程\n- \\> 0 　　　　意思是等待进程 ID 等于 pid 的子进程\n\n##### options 参数\n\n*options* 是一个组合值，包含 0 个或多个一下值：\n\nWNOHANG： 如果没有孩子死亡则立即返回\n\nWUNTRACED：\n\n。。。\n\n### 返回值\n\n##　pipe, pipe2 - 创建管道（进程间通信）\n\n参考： https://man7.org/linux/man-pages/man2/pipe.2.html\n\n### 函数原型\n\n```c\n #include <unistd.h>\n\n       int pipe(int pipefd[2]);\n\n#define _GNU_SOURCE             /* See feature_test_macros(7) */\n#include <fcntl.h>              /* Definition of O_* constants */\n#include <unistd.h>\n\n       int pipe2(int pipefd[2], int flags);\n```\n\n---\n\n举例：\n\n```c\nint fd[2];\nint x = pipe(fd);    // 先\nint pid = fork();    // 后\n\nchar buf[1024];\nchar * str = \"hello world\";\nif(x == -1) {\n    perror(\"error\");\n    exit(1);\n}\n\nif(pid > 0) {\n    printf(\"i'm parent\\n\");\n    write(fd[1], str, strlen(str));\n} else if(pid == 0) {\n    printf(\"i am child\\n\");\n    int ret = read(fd[0], buf, 1024);\n    write(STDOUT_FILENO, buf, ret);\n}\n```\n\n### 描述\n\npipe() 创建一个 **单向** 的可以用于进程间通信的数据通道。 *pipefd[]* 用来返回两个分别指向管道入端和出端的文件描述符。  *pipefd[0]* 指的是管道的读端， *pipefd[1]* 为写端。写入写端的数据会被内核缓冲，直到从读端读取数据，写入的数据只能被读取一次，不能重复读取。  \n\n### 返回值\n\n成功时，返回 0\n\n失败时，返回 -1，设置 errno，并且 *pipefd* 不会被改变。\n\n## mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）\n\n参考： https://man7.org/linux/man-pages/man2/mmap.2.html\n\n### 函数原型\n\n```c\n   #include <sys/mman.h>\n\n   void *mmap(void *addr, size_t length, int prot, int flags,\n              int fd, off_t offset);\n   int munmap(void *addr, size_t length);\n```\n\n---\n\n举例：\n\n\n\n\n\n### 描述\n\nmmap() 在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址子在 *addr* 中指定。 *length* 指定映射的大小（必须大于0）。如果 *addr* 为NULL，那么内核选择(页面对齐的)地址来创建映射。这种方式创建的 mmap() 具有最好的可移植性。如果 *addr* 不为NULL，那么内核将其作为放置映射的位置的提示。 *offset* 必须是内存页（page size = 4096）的整数倍，可以通过 sysconf(_SC_PAGE_SIZE) 的返回值查看。\n\n文件映射的内容，初始化时使用从文件描述符 *fd* 引用的文件(或其他对象)的偏移量 *offset* 处开始的 *length* 字节大小的映射空间。\n\n![image-20210822022207629](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/linux-c-基本函数/image-20210822022207629.41lugd2750u0.png)\n\n#### prot 参数\n\n*prot* 指定映射的内存保护权限。有下面几个宏：\n\n- PROT_EXEC：映射的内存页可以执行\n- PROT_READ：映射的内存页可以读\n- PROT_WRITE：映射的内存页可以写\n- PROT_NONE：映射的内存页不可访问\n\n可以组合，比如 PROT_READ | PROT_WRITE 。\n\n#### flag 参数\n\n*flags* 参数确定对映射的更新是否对映射同一区域的其他进程可见，以及是否对底层文件进行更新。\n\n此行为由包含以下值之一确定：\n\n- MAP_SHARED： 分享这个映射。映射的更新对映射同一区域的其它进程是可见的。*并且(在文件支持映射的情况下)将被传递到底层文件。\n- MAP_PRIVATE： 创建私有的 **写时拷贝** 映射。\n\n还能由以下值的零个或多个确定：\n\n- MAP_32BIT\n- MAP_ANON\n\n。。。\n\n### 返回值\n\nmmap() :\n\n成功时，返回一个指向映射区域的指针。\n\n失败时，值 MAP_FAILED （类型为 （void *）-1 ），并设置 errno。\n\nmunmap()：\n","slug":"linux-c-基本函数","published":1,"updated":"2022-04-05T18:17:16.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1mhhtcz00019icb0pkq1t23","content":"<h2 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open\"></a>open</h2><h3 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>open 函数可以打开 pathname 指定的文件，如果这个指定的文件不存在，可以选择创建它（前提是 O_CREAT 在 flags 中指定了），而指定了 O_CREAT 后需要指定第三个参数 mode 。</p>\n<p>其中 flags 定义的宏在 fcntl.h 头文件中。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_CREAT, <span class=\"number\">0644</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该语句打开当前目录下的 yuhan.txt 文件，指定打开的权限是可读可写，如果该文件不存在则创建它，创建该文件的权限为 rw-r–r–。</p>\n<p>前面加0，0644代表八进制数。</p>\n<p><strong>如果不创建：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>该函数返回一个 int 类型的文件描述符（非负整数），搭配 read、write 等函数使用。</p>\n<p>成功调用的返回值是当前未被进程打开的最小的可用的文件描述符。</p>\n<p><strong>如果失败：</strong></p>\n<p>返回 -1 并且设置 errno , errno 是被系统创建的一个用来标识错误的变量，用 perror 输出错误。</p>\n<h3 id=\"其它描述\"><a href=\"#其它描述\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><ul>\n<li><p>默认的该函数返回的文件描述符所打开的文件处于始终打开的状态，可以用 close 函数关闭。</p>\n</li>\n<li><p>参数 flags 必须包含 <strong>O_RDONLY、O_WRONLY、O_RDWR</strong> 中的一个。</p>\n</li>\n<li><p>O_TRUNC 覆盖写</p>\n</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC , <span class=\"number\">0644</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>O_APPEND 追加写</li>\n<li>创建文件 creat 可以用 open 实现，使用 flags ： O_CREAT|O_WRONLY|O_TRUNC </li>\n</ul>\n<p>比较重要的大概就这一些。</p>\n<h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h2><h3 id=\"函数原型-1\"><a href=\"#函数原型-1\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>read 函数通过文件描述符 fd 读取 count 字节大小的内容到 buf 缓冲区中</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">// yuhan.txt: &lt;hello i&#x27;am yuhanOvo&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(read(fd, buf, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; buf: %s&quot;</span>, buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt; buf: hello i am yuhanOvo</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>调用成功时，返回读取的字节数（为0时，则表示读到了文件结尾）。并且，下次读取文件的位置被偏移了返回值的大小个字节。也就是第二次 read 会从第一次 read 的结尾处继续读取。</p>\n<p>如果返回的值小于请求的参数 count ， 这不是一个错误，因为剩余可读取的字节数小于 count 的大小是完全有可能的。*或者我们可能在一个管道上读取。其它原因不展开。</p>\n<p>调用失败时，返回 -1 ，并且系统会设置 errno 来指示错误。</p>\n<p>比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = read(<span class=\"number\">1000</span>, buf, <span class=\"number\">1024</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;read error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt; read error: Bad file descriptor</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其它描述-1\"><a href=\"#其它描述-1\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><p>关于 count 的大小选取，如果比 SSIZE_MAX 大，结果未定义。</p>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\"write\"></a>write</h2><h3 id=\"函数原型-2\"><a href=\"#函数原型-2\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>write 函数从缓冲区 buf 中读取 count 字节的内容写入文件描述符 fd 所指向的文件中。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_TRUNC);</span><br><span class=\"line\"><span class=\"keyword\">char</span> *hello = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">write(fd, hello, <span class=\"built_in\">strlen</span>(hello));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>调用成功时，返回写入的字节数。</p>\n<p>调用失败时，返回 -1，并设置 errno 。</p>\n<p><strong>注意：</strong></p>\n<p>返回的字节数可能小于 count 的大小，可能的原因之一是写入的硬件磁盘的容量不够。</p>\n<h3 id=\"其它描述-2\"><a href=\"#其它描述-2\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><p>暂无</p>\n<h2 id=\"fcntl\"><a href=\"#fcntl\" class=\"headerlink\" title=\"fcntl\"></a>fcntl</h2><h3 id=\"函数原型-3\"><a href=\"#函数原型-3\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ... <span class=\"comment\">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>fcntl 函数用来控制文件描述符</p>\n<p>cmd 可以是各种被设置好的宏，当 cmd 表示为不同的宏时 fcntl 具有不同的功能。</p>\n<h4 id=\"复制描述符\"><a href=\"#复制描述符\" class=\"headerlink\" title=\"复制描述符\"></a>复制描述符</h4><p>F_DUPFD (int类型)</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_TRUNC);</span><br><span class=\"line\"><span class=\"keyword\">int</span> fd2 = fcntl(fd, F_DUPFD, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此时 fd2 和 fd 所指向的文件相同。</p>\n<p>注意第三个参数 0 ，代表返回一个大于等于 0 的可用的文件描述符。</p>\n<p>这个函数还不太熟悉。</p>\n<h2 id=\"lseek-定位读-写文件偏移量\"><a href=\"#lseek-定位读-写文件偏移量\" class=\"headerlink\" title=\"lseek - 定位读/写文件偏移量\"></a>lseek - 定位读/写文件偏移量</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/lseek.2.html\">https://man7.org/linux/man-pages/man2/lseek.2.html</a></p>\n<h3 id=\"函数原型-4\"><a href=\"#函数原型-4\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">off_t</span> <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定位读或者写文件的偏移量。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>lseek 函数根据偏移量 <em>offset</em> 和偏移模式 <em>whence</em> 来定位 <em>fd</em> 所关联文件的偏移位置。 </p>\n<h4 id=\"whence-参数\"><a href=\"#whence-参数\" class=\"headerlink\" title=\"whence 参数\"></a>whence 参数</h4><p>SEEK_SET：  从文件开始的位置偏移 <em>offset</em> 个偏移量</p>\n<p>SEEK_CUR：  从文件指针当前挪到的位置偏移 <em>offset</em> 个偏移量</p>\n<p>SEEK_END： 从文件结尾的位置偏移 <em>offset</em> 个偏移量</p>\n<hr>\n<p><em>offset</em> 可以是负数， 表示向左偏移。</p>\n<p>lseek 函数允许偏移量设置在文件的结尾之后，但是这将不会改变文件的大小，只有在偏移之后再写入数据到文件之后，那些偏移了但是还没有填入数据的位置为一个空洞（’\\0’）。</p>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，返回从文件开头到所偏移到的位置一共的偏移量（以字节为单位）。</p>\n<p>失败时，返回 -1， 设置 errno。</p>\n<h3 id=\"一些用处\"><a href=\"#一些用处\" class=\"headerlink\" title=\"一些用处\"></a>一些用处</h3><p>拓展文件大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR | O_CREAT, <span class=\"number\">0644</span>);</span><br><span class=\"line\">lseek(fd, <span class=\"number\">100</span>, SEEK_SET);</span><br><span class=\"line\">write(fd, <span class=\"string\">&quot;\\0&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此文件大小为 101个字节。</p>\n<p>其它方式还有：</p>\n<p>ftruncate() </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">truncate</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">off_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ftruncate</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>ftruncate(fd, 100);</p>\n<h2 id=\"dup-dup2-dup3-复制一个文件描述符\"><a href=\"#dup-dup2-dup3-复制一个文件描述符\" class=\"headerlink\" title=\"dup, dup2, dup3 - 复制一个文件描述符\"></a>dup, dup2, dup3 - 复制一个文件描述符</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/dup.2.html\">https://man7.org/linux/man-pages/man2/dup.2.html</a></p>\n<h3 id=\"函数原型-5\"><a href=\"#函数原型-5\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _GNU_SOURCE             <span class=\"comment\">/* See feature_test_macros(7) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span>              <span class=\"comment\">/* Definition of O_* constants */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup3</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<p>dup() :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR);</span><br><span class=\"line\"><span class=\"keyword\">int</span> new_fd = dup(fd);</span><br><span class=\"line\">write(new_fd, <span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>dup2() :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR);</span><br><span class=\"line\">dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;HELLO WORLD&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210821195326502.1h80zd76196o.png\" alt=\"image-20210821195326502\"></p>\n<h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>暂无</p>\n<h3 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，这些系统调用将返回新的文件描述符。</p>\n<p>失败时，返回 -1， 设置 errno。</p>\n<h2 id=\"fork-创建一个子进程\"><a href=\"#fork-创建一个子进程\" class=\"headerlink\" title=\"fork - 创建一个子进程\"></a>fork - 创建一个子进程</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">https://man7.org/linux/man-pages/man2/fork.2.html</a></p>\n<h3 id=\"函数原型-6\"><a href=\"#函数原型-6\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>fork函数用来创建一个子进程。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210817145349164.3vfbf8e1tka0.png\" alt=\"image-20210817145349164\"></p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start fork()\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span> pid = fork();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;fork error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child process\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent process\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;end\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;  start fork()</span></span><br><span class=\"line\"><span class=\"comment\">    parent process</span></span><br><span class=\"line\"><span class=\"comment\">    end</span></span><br><span class=\"line\"><span class=\"comment\">    child process</span></span><br><span class=\"line\"><span class=\"comment\">    end</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>fork() 函数通过重复调用进程创建一个新的进程，这个新的进程被称为子进程，调用 fork() 的进程被称为父进程。子进程和父进程在独立的内存空间中运行。在 fork() 时，两块内存空间具有相同的内容。</p>\n<p>子进程与父进程完全相同，除了一下几点：</p>\n<ul>\n<li>子进程有它独特的进程 ID</li>\n<li>子进程的父进程ID与父进程ID相同。</li>\n</ul>\n<p>等等</p>\n<h3 id=\"返回值-5\"><a href=\"#返回值-5\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，在父进程中，返回子进程的 PID；在子进程中，返回0。</p>\n<p>失败时，父进程中返回 -1，并且没有子进程被创建。并且，errno 被设置。</p>\n<h2 id=\"getpid-getppid-获取进程标识\"><a href=\"#getpid-getppid-获取进程标识\" class=\"headerlink\" title=\"getpid, getppid - 获取进程标识\"></a>getpid, getppid - 获取进程标识</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/getpid.2.html\">https://man7.org/linux/man-pages/man2/getpid.2.html</a></p>\n<h3 id=\"函数原型-7\"><a href=\"#函数原型-7\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">getppid</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>getpid() 返回该进程的 ID（PID）。</p>\n<p>getppid() 返回该进程的父进程的 ID。</p>\n<h2 id=\"exec系列-执行一个文件\"><a href=\"#exec系列-执行一个文件\" class=\"headerlink\" title=\"exec系列 - 执行一个文件\"></a>exec系列 - 执行一个文件</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man3/exec.3.html\">https://man7.org/linux/man-pages/man3/exec.3.html</a></p>\n<h3 id=\"函数原型-8\"><a href=\"#函数原型-8\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">extern</span> <span class=\"keyword\">char</span> **environ;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvpe</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以按照函数名的后缀对其进行分类：</p>\n<h4 id=\"l-execl-execlp-execle\"><a href=\"#l-execl-execlp-execle\" class=\"headerlink\" title=\"l - execl(), execlp(), execle()\"></a>l - execl(), execlp(), execle()</h4><p>这三个函数有一个共同的参数 const char *arg，这个const char *arg和后面的省略号可以看成 arg0，arg1，arg2 … … argn。这些参数构成了执行程序的参数列表。第一个参数 const char *file/pathname，约定俗成，应该指向正在执行的文件的文件名。</p>\n<p>后面的参数列表必须以空指针 NULL 结尾，用来告诉这个可变参数的函数这已经是最后一个参数了。</p>\n<p>除此之外，参数列表的第一个参数 arg0 也必须是执行的文件名。拿execlp举例来说，execlp根据环境变量中的路径找到pathname所指向的文件名，然后执行该文件，执行该文件的 argv[0]，argv[1]，… ，argv[n] 与参数列表中 arg0，arg1，arg2 … … argn 相对应，而argv[0] 正是当前执行的文件名，也就是说，除了第一个参数 const char *file/pathname 要指定文件名，第二个参数 arg0 也需要指定文件名。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execlp(<span class=\"string\">&quot;ls&quot;</span>, <span class=\"string\">&quot;ls&quot;</span>, <span class=\"string\">&quot;-l&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execl(<span class=\"string\">&quot;../forkProcess/out/fork&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------</span></span><br><span class=\"line\">execlp(<span class=\"string\">&quot;date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execl(<span class=\"string\">&quot;/usr/bin/date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execle(<span class=\"string\">&quot;/usr/bin/date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-execv-execvp-execvpe\"><a href=\"#v-execv-execvp-execvpe\" class=\"headerlink\" title=\"v - execv(), execvp(), execvpe()\"></a>v - execv(), execvp(), execvpe()</h4><h4 id=\"e-execle-execvpe\"><a href=\"#e-execle-execvpe\" class=\"headerlink\" title=\"e - execle(), execvpe()\"></a>e - execle(), execvpe()</h4><h4 id=\"p-execlp-execvp-execvpe\"><a href=\"#p-execlp-execvp-execvpe\" class=\"headerlink\" title=\"p - execlp(), execvp(), execvpe()\"></a>p - execlp(), execvp(), execvpe()</h4><h3 id=\"描述-4\"><a href=\"#描述-4\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>exec() 系列函数用一个新的进程映像替换当前进程映像。也就是说当前进程的 PID 和其父进程都没有改变，而该进程所执行的东西已经变为了 exec 所执行的文件。</p>\n<p>该系列的函数是在 execve 函数的基础上是实现的。execve 函数参考：<a href=\"https://man7.org/linux/man-pages/man2/execve.2.html\">https://man7.org/linux/man-pages/man2/execve.2.html</a></p>\n<h3 id=\"返回值-6\"><a href=\"#返回值-6\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>exec() 系列函数仅在发生错误时返回 -1，并设置 errno。</p>\n<h2 id=\"wait-waitpid-waitid-等待进程改变状态\"><a href=\"#wait-waitpid-waitid-等待进程改变状态\" class=\"headerlink\" title=\"wait, waitpid, waitid - 等待进程改变状态\"></a>wait, waitpid, waitid - 等待进程改变状态</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/waitpid.2.html\">https://man7.org/linux/man-pages/man2/waitpid.2.html</a></p>\n<h3 id=\"函数原型-9\"><a href=\"#函数原型-9\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span> *wstatus)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> *wstatus, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">waitid</span><span class=\"params\">(<span class=\"keyword\">idtype_t</span> idtype, <span class=\"keyword\">id_t</span> id, <span class=\"keyword\">siginfo_t</span> *infop, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\">                       <span class=\"comment\">/* 这是glibc和POSIX接口;有关原始系统调用的信息，请参阅NOTES。 */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-5\"><a href=\"#描述-5\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>所有这些 <strong>系统调用</strong> 都是用来等待正在进行的子进程的状态发生变化的，并且获取到子进程状态发生变化的具体信息。</p>\n<p><strong>状态改变</strong> 可以被认为是：</p>\n<ul>\n<li>子进程终止</li>\n<li>子进程被一个信号中断了</li>\n<li>子进程被一个信号恢复了</li>\n</ul>\n<p>在子进程结束的情况下，父进程执行等待可以有效释放子进程的系统资源，如果没有执行等待，那么结束的子进程将以一个“僵尸”状态继续被保留。</p>\n<p>如果一个子进程改变了状态，这些调用将立即返回，否则，它们会阻塞，直到子进程改变状态或信号处理程序中断调用。</p>\n<h4 id=\"wait-和-waitpid\"><a href=\"#wait-和-waitpid\" class=\"headerlink\" title=\"wait 和 waitpid\"></a>wait 和 waitpid</h4><p>wait() <strong>系统调用</strong> 将暂停调用线程的执行，直到它的一个子线程终止。</p>\n<p>函数调用  <em>wait(int *wstatus)</em>  等同于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">waitpid(<span class=\"number\">-1</span>, &amp;wstatus, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>waitpid <strong>系统调用</strong> 挂起当前调用线程，直到由 <em>pid</em> 参数指定的子进程发生变化。默认情况下，waitpid 只等待终止的子进程，但此行为可以通过修改参数 <em>options</em> 改变。</p>\n<h5 id=\"pid-参数\"><a href=\"#pid-参数\" class=\"headerlink\" title=\"pid 参数\"></a>pid 参数</h5><p><em>pid</em> 的值可以是：</p>\n<ul>\n<li>&lt; -1 　　　　意思是等待任何*进程组 ID 等于 pid 绝对值的子进程</li>\n<li>-1 　　　　　意思是任何子进程</li>\n<li>0 　　　　　意思是等待任何进程组 ID 等于该调用 waitpid 的进程的进程组 ID 的子进程</li>\n<li>&gt; 0 　　　　意思是等待进程 ID 等于 pid 的子进程</li>\n</ul>\n<h5 id=\"options-参数\"><a href=\"#options-参数\" class=\"headerlink\" title=\"options 参数\"></a>options 参数</h5><p><em>options</em> 是一个组合值，包含 0 个或多个一下值：</p>\n<p>WNOHANG： 如果没有孩子死亡则立即返回</p>\n<p>WUNTRACED：</p>\n<p>。。。</p>\n<h3 id=\"返回值-7\"><a href=\"#返回值-7\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><h2 id=\"pipe-pipe2-创建管道（进程间通信）\"><a href=\"#pipe-pipe2-创建管道（进程间通信）\" class=\"headerlink\" title=\"pipe, pipe2 - 创建管道（进程间通信）\"></a>pipe, pipe2 - 创建管道（进程间通信）</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/pipe.2.html\">https://man7.org/linux/man-pages/man2/pipe.2.html</a></p>\n<h3 id=\"函数原型-10\"><a href=\"#函数原型-10\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _GNU_SOURCE             <span class=\"comment\">/* See feature_test_macros(7) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span>              <span class=\"comment\">/* Definition of O_* constants */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe2</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>], <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = pipe(fd);    <span class=\"comment\">// 先</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> pid = fork();    <span class=\"comment\">// 后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> * str = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(x == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i&#x27;m parent\\n&quot;</span>);</span><br><span class=\"line\">    write(fd[<span class=\"number\">1</span>], str, <span class=\"built_in\">strlen</span>(str));</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i am child\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = read(fd[<span class=\"number\">0</span>], buf, <span class=\"number\">1024</span>);</span><br><span class=\"line\">    write(STDOUT_FILENO, buf, ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-6\"><a href=\"#描述-6\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>pipe() 创建一个 <strong>单向</strong> 的可以用于进程间通信的数据通道。 <em>pipefd[]</em> 用来返回两个分别指向管道入端和出端的文件描述符。  <em>pipefd[0]</em> 指的是管道的读端， <em>pipefd[1]</em> 为写端。写入写端的数据会被内核缓冲，直到从读端读取数据，写入的数据只能被读取一次，不能重复读取。  </p>\n<h3 id=\"返回值-8\"><a href=\"#返回值-8\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，返回 0</p>\n<p>失败时，返回 -1，设置 errno，并且 <em>pipefd</em> 不会被改变。</p>\n<h2 id=\"mmap-munmap-映射或取消映射文件或设备到内存中（进程间通信）\"><a href=\"#mmap-munmap-映射或取消映射文件或设备到内存中（进程间通信）\" class=\"headerlink\" title=\"mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）\"></a>mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">https://man7.org/linux/man-pages/man2/mmap.2.html</a></p>\n<h3 id=\"函数原型-11\"><a href=\"#函数原型-11\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<h3 id=\"描述-7\"><a href=\"#描述-7\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>mmap() 在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址子在 <em>addr</em> 中指定。 <em>length</em> 指定映射的大小（必须大于0）。如果 <em>addr</em> 为NULL，那么内核选择(页面对齐的)地址来创建映射。这种方式创建的 mmap() 具有最好的可移植性。如果 <em>addr</em> 不为NULL，那么内核将其作为放置映射的位置的提示。 <em>offset</em> 必须是内存页（page size = 4096）的整数倍，可以通过 sysconf(_SC_PAGE_SIZE) 的返回值查看。</p>\n<p>文件映射的内容，初始化时使用从文件描述符 <em>fd</em> 引用的文件(或其他对象)的偏移量 <em>offset</em> 处开始的 <em>length</em> 字节大小的映射空间。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210822022207629.41lugd2750u0.png\" alt=\"image-20210822022207629\"></p>\n<h4 id=\"prot-参数\"><a href=\"#prot-参数\" class=\"headerlink\" title=\"prot 参数\"></a>prot 参数</h4><p><em>prot</em> 指定映射的内存保护权限。有下面几个宏：</p>\n<ul>\n<li>PROT_EXEC：映射的内存页可以执行</li>\n<li>PROT_READ：映射的内存页可以读</li>\n<li>PROT_WRITE：映射的内存页可以写</li>\n<li>PROT_NONE：映射的内存页不可访问</li>\n</ul>\n<p>可以组合，比如 PROT_READ | PROT_WRITE 。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p><em>flags</em> 参数确定对映射的更新是否对映射同一区域的其他进程可见，以及是否对底层文件进行更新。</p>\n<p>此行为由包含以下值之一确定：</p>\n<ul>\n<li>MAP_SHARED： 分享这个映射。映射的更新对映射同一区域的其它进程是可见的。*并且(在文件支持映射的情况下)将被传递到底层文件。</li>\n<li>MAP_PRIVATE： 创建私有的 <strong>写时拷贝</strong> 映射。</li>\n</ul>\n<p>还能由以下值的零个或多个确定：</p>\n<ul>\n<li>MAP_32BIT</li>\n<li>MAP_ANON</li>\n</ul>\n<p>。。。</p>\n<h3 id=\"返回值-9\"><a href=\"#返回值-9\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>mmap() :</p>\n<p>成功时，返回一个指向映射区域的指针。</p>\n<p>失败时，值 MAP_FAILED （类型为 （void *）-1 ），并设置 errno。</p>\n<p>munmap()：</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open\"></a>open</h2><h3 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>","more":"<p>open 函数可以打开 pathname 指定的文件，如果这个指定的文件不存在，可以选择创建它（前提是 O_CREAT 在 flags 中指定了），而指定了 O_CREAT 后需要指定第三个参数 mode 。</p>\n<p>其中 flags 定义的宏在 fcntl.h 头文件中。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_CREAT, <span class=\"number\">0644</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该语句打开当前目录下的 yuhan.txt 文件，指定打开的权限是可读可写，如果该文件不存在则创建它，创建该文件的权限为 rw-r–r–。</p>\n<p>前面加0，0644代表八进制数。</p>\n<p><strong>如果不创建：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>该函数返回一个 int 类型的文件描述符（非负整数），搭配 read、write 等函数使用。</p>\n<p>成功调用的返回值是当前未被进程打开的最小的可用的文件描述符。</p>\n<p><strong>如果失败：</strong></p>\n<p>返回 -1 并且设置 errno , errno 是被系统创建的一个用来标识错误的变量，用 perror 输出错误。</p>\n<h3 id=\"其它描述\"><a href=\"#其它描述\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><ul>\n<li><p>默认的该函数返回的文件描述符所打开的文件处于始终打开的状态，可以用 close 函数关闭。</p>\n</li>\n<li><p>参数 flags 必须包含 <strong>O_RDONLY、O_WRONLY、O_RDWR</strong> 中的一个。</p>\n</li>\n<li><p>O_TRUNC 覆盖写</p>\n</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC , <span class=\"number\">0644</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>O_APPEND 追加写</li>\n<li>创建文件 creat 可以用 open 实现，使用 flags ： O_CREAT|O_WRONLY|O_TRUNC </li>\n</ul>\n<p>比较重要的大概就这一些。</p>\n<h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h2><h3 id=\"函数原型-1\"><a href=\"#函数原型-1\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>read 函数通过文件描述符 fd 读取 count 字节大小的内容到 buf 缓冲区中</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">// yuhan.txt: &lt;hello i&#x27;am yuhanOvo&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(read(fd, buf, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; buf: %s&quot;</span>, buf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt; buf: hello i am yuhanOvo</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>调用成功时，返回读取的字节数（为0时，则表示读到了文件结尾）。并且，下次读取文件的位置被偏移了返回值的大小个字节。也就是第二次 read 会从第一次 read 的结尾处继续读取。</p>\n<p>如果返回的值小于请求的参数 count ， 这不是一个错误，因为剩余可读取的字节数小于 count 的大小是完全有可能的。*或者我们可能在一个管道上读取。其它原因不展开。</p>\n<p>调用失败时，返回 -1 ，并且系统会设置 errno 来指示错误。</p>\n<p>比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = read(<span class=\"number\">1000</span>, buf, <span class=\"number\">1024</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;read error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt;&gt; read error: Bad file descriptor</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其它描述-1\"><a href=\"#其它描述-1\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><p>关于 count 的大小选取，如果比 SSIZE_MAX 大，结果未定义。</p>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\"write\"></a>write</h2><h3 id=\"函数原型-2\"><a href=\"#函数原型-2\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>write 函数从缓冲区 buf 中读取 count 字节的内容写入文件描述符 fd 所指向的文件中。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_TRUNC);</span><br><span class=\"line\"><span class=\"keyword\">char</span> *hello = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">write(fd, hello, <span class=\"built_in\">strlen</span>(hello));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>调用成功时，返回写入的字节数。</p>\n<p>调用失败时，返回 -1，并设置 errno 。</p>\n<p><strong>注意：</strong></p>\n<p>返回的字节数可能小于 count 的大小，可能的原因之一是写入的硬件磁盘的容量不够。</p>\n<h3 id=\"其它描述-2\"><a href=\"#其它描述-2\" class=\"headerlink\" title=\"其它描述\"></a>其它描述</h3><p>暂无</p>\n<h2 id=\"fcntl\"><a href=\"#fcntl\" class=\"headerlink\" title=\"fcntl\"></a>fcntl</h2><h3 id=\"函数原型-3\"><a href=\"#函数原型-3\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ... <span class=\"comment\">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>fcntl 函数用来控制文件描述符</p>\n<p>cmd 可以是各种被设置好的宏，当 cmd 表示为不同的宏时 fcntl 具有不同的功能。</p>\n<h4 id=\"复制描述符\"><a href=\"#复制描述符\" class=\"headerlink\" title=\"复制描述符\"></a>复制描述符</h4><p>F_DUPFD (int类型)</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;yuhan.txt&quot;</span>, O_RDWR | O_TRUNC);</span><br><span class=\"line\"><span class=\"keyword\">int</span> fd2 = fcntl(fd, F_DUPFD, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此时 fd2 和 fd 所指向的文件相同。</p>\n<p>注意第三个参数 0 ，代表返回一个大于等于 0 的可用的文件描述符。</p>\n<p>这个函数还不太熟悉。</p>\n<h2 id=\"lseek-定位读-写文件偏移量\"><a href=\"#lseek-定位读-写文件偏移量\" class=\"headerlink\" title=\"lseek - 定位读/写文件偏移量\"></a>lseek - 定位读/写文件偏移量</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/lseek.2.html\">https://man7.org/linux/man-pages/man2/lseek.2.html</a></p>\n<h3 id=\"函数原型-4\"><a href=\"#函数原型-4\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">off_t</span> <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定位读或者写文件的偏移量。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>lseek 函数根据偏移量 <em>offset</em> 和偏移模式 <em>whence</em> 来定位 <em>fd</em> 所关联文件的偏移位置。 </p>\n<h4 id=\"whence-参数\"><a href=\"#whence-参数\" class=\"headerlink\" title=\"whence 参数\"></a>whence 参数</h4><p>SEEK_SET：  从文件开始的位置偏移 <em>offset</em> 个偏移量</p>\n<p>SEEK_CUR：  从文件指针当前挪到的位置偏移 <em>offset</em> 个偏移量</p>\n<p>SEEK_END： 从文件结尾的位置偏移 <em>offset</em> 个偏移量</p>\n<hr>\n<p><em>offset</em> 可以是负数， 表示向左偏移。</p>\n<p>lseek 函数允许偏移量设置在文件的结尾之后，但是这将不会改变文件的大小，只有在偏移之后再写入数据到文件之后，那些偏移了但是还没有填入数据的位置为一个空洞（’\\0’）。</p>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，返回从文件开头到所偏移到的位置一共的偏移量（以字节为单位）。</p>\n<p>失败时，返回 -1， 设置 errno。</p>\n<h3 id=\"一些用处\"><a href=\"#一些用处\" class=\"headerlink\" title=\"一些用处\"></a>一些用处</h3><p>拓展文件大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR | O_CREAT, <span class=\"number\">0644</span>);</span><br><span class=\"line\">lseek(fd, <span class=\"number\">100</span>, SEEK_SET);</span><br><span class=\"line\">write(fd, <span class=\"string\">&quot;\\0&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此文件大小为 101个字节。</p>\n<p>其它方式还有：</p>\n<p>ftruncate() </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">truncate</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">off_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ftruncate</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>ftruncate(fd, 100);</p>\n<h2 id=\"dup-dup2-dup3-复制一个文件描述符\"><a href=\"#dup-dup2-dup3-复制一个文件描述符\" class=\"headerlink\" title=\"dup, dup2, dup3 - 复制一个文件描述符\"></a>dup, dup2, dup3 - 复制一个文件描述符</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/dup.2.html\">https://man7.org/linux/man-pages/man2/dup.2.html</a></p>\n<h3 id=\"函数原型-5\"><a href=\"#函数原型-5\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _GNU_SOURCE             <span class=\"comment\">/* See feature_test_macros(7) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span>              <span class=\"comment\">/* Definition of O_* constants */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup3</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<p>dup() :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR);</span><br><span class=\"line\"><span class=\"keyword\">int</span> new_fd = dup(fd);</span><br><span class=\"line\">write(new_fd, <span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>dup2() :</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd = open(<span class=\"string\">&quot;txt&quot;</span>, O_RDWR);</span><br><span class=\"line\">dup2(fd, STDOUT_FILENO);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;HELLO WORLD&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210821195326502.1h80zd76196o.png\" alt=\"image-20210821195326502\"></p>\n<h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>暂无</p>\n<h3 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，这些系统调用将返回新的文件描述符。</p>\n<p>失败时，返回 -1， 设置 errno。</p>\n<h2 id=\"fork-创建一个子进程\"><a href=\"#fork-创建一个子进程\" class=\"headerlink\" title=\"fork - 创建一个子进程\"></a>fork - 创建一个子进程</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">https://man7.org/linux/man-pages/man2/fork.2.html</a></p>\n<h3 id=\"函数原型-6\"><a href=\"#函数原型-6\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>fork函数用来创建一个子进程。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210817145349164.3vfbf8e1tka0.png\" alt=\"image-20210817145349164\"></p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start fork()\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span> pid = fork();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;fork error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child process\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent process\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;end\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&gt;&gt;  start fork()</span></span><br><span class=\"line\"><span class=\"comment\">    parent process</span></span><br><span class=\"line\"><span class=\"comment\">    end</span></span><br><span class=\"line\"><span class=\"comment\">    child process</span></span><br><span class=\"line\"><span class=\"comment\">    end</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>fork() 函数通过重复调用进程创建一个新的进程，这个新的进程被称为子进程，调用 fork() 的进程被称为父进程。子进程和父进程在独立的内存空间中运行。在 fork() 时，两块内存空间具有相同的内容。</p>\n<p>子进程与父进程完全相同，除了一下几点：</p>\n<ul>\n<li>子进程有它独特的进程 ID</li>\n<li>子进程的父进程ID与父进程ID相同。</li>\n</ul>\n<p>等等</p>\n<h3 id=\"返回值-5\"><a href=\"#返回值-5\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，在父进程中，返回子进程的 PID；在子进程中，返回0。</p>\n<p>失败时，父进程中返回 -1，并且没有子进程被创建。并且，errno 被设置。</p>\n<h2 id=\"getpid-getppid-获取进程标识\"><a href=\"#getpid-getppid-获取进程标识\" class=\"headerlink\" title=\"getpid, getppid - 获取进程标识\"></a>getpid, getppid - 获取进程标识</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/getpid.2.html\">https://man7.org/linux/man-pages/man2/getpid.2.html</a></p>\n<h3 id=\"函数原型-7\"><a href=\"#函数原型-7\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">getppid</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>getpid() 返回该进程的 ID（PID）。</p>\n<p>getppid() 返回该进程的父进程的 ID。</p>\n<h2 id=\"exec系列-执行一个文件\"><a href=\"#exec系列-执行一个文件\" class=\"headerlink\" title=\"exec系列 - 执行一个文件\"></a>exec系列 - 执行一个文件</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man3/exec.3.html\">https://man7.org/linux/man-pages/man3/exec.3.html</a></p>\n<h3 id=\"函数原型-8\"><a href=\"#函数原型-8\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">extern</span> <span class=\"keyword\">char</span> **environ;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"comment\">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvpe</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *file, <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span> *<span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以按照函数名的后缀对其进行分类：</p>\n<h4 id=\"l-execl-execlp-execle\"><a href=\"#l-execl-execlp-execle\" class=\"headerlink\" title=\"l - execl(), execlp(), execle()\"></a>l - execl(), execlp(), execle()</h4><p>这三个函数有一个共同的参数 const char *arg，这个const char *arg和后面的省略号可以看成 arg0，arg1，arg2 … … argn。这些参数构成了执行程序的参数列表。第一个参数 const char *file/pathname，约定俗成，应该指向正在执行的文件的文件名。</p>\n<p>后面的参数列表必须以空指针 NULL 结尾，用来告诉这个可变参数的函数这已经是最后一个参数了。</p>\n<p>除此之外，参数列表的第一个参数 arg0 也必须是执行的文件名。拿execlp举例来说，execlp根据环境变量中的路径找到pathname所指向的文件名，然后执行该文件，执行该文件的 argv[0]，argv[1]，… ，argv[n] 与参数列表中 arg0，arg1，arg2 … … argn 相对应，而argv[0] 正是当前执行的文件名，也就是说，除了第一个参数 const char *file/pathname 要指定文件名，第二个参数 arg0 也需要指定文件名。</p>\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execlp(<span class=\"string\">&quot;ls&quot;</span>, <span class=\"string\">&quot;ls&quot;</span>, <span class=\"string\">&quot;-l&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execl(<span class=\"string\">&quot;../forkProcess/out/fork&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------</span></span><br><span class=\"line\">execlp(<span class=\"string\">&quot;date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execl(<span class=\"string\">&quot;/usr/bin/date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">execle(<span class=\"string\">&quot;/usr/bin/date&quot;</span>, <span class=\"string\">&quot;date&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v-execv-execvp-execvpe\"><a href=\"#v-execv-execvp-execvpe\" class=\"headerlink\" title=\"v - execv(), execvp(), execvpe()\"></a>v - execv(), execvp(), execvpe()</h4><h4 id=\"e-execle-execvpe\"><a href=\"#e-execle-execvpe\" class=\"headerlink\" title=\"e - execle(), execvpe()\"></a>e - execle(), execvpe()</h4><h4 id=\"p-execlp-execvp-execvpe\"><a href=\"#p-execlp-execvp-execvpe\" class=\"headerlink\" title=\"p - execlp(), execvp(), execvpe()\"></a>p - execlp(), execvp(), execvpe()</h4><h3 id=\"描述-4\"><a href=\"#描述-4\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>exec() 系列函数用一个新的进程映像替换当前进程映像。也就是说当前进程的 PID 和其父进程都没有改变，而该进程所执行的东西已经变为了 exec 所执行的文件。</p>\n<p>该系列的函数是在 execve 函数的基础上是实现的。execve 函数参考：<a href=\"https://man7.org/linux/man-pages/man2/execve.2.html\">https://man7.org/linux/man-pages/man2/execve.2.html</a></p>\n<h3 id=\"返回值-6\"><a href=\"#返回值-6\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>exec() 系列函数仅在发生错误时返回 -1，并设置 errno。</p>\n<h2 id=\"wait-waitpid-waitid-等待进程改变状态\"><a href=\"#wait-waitpid-waitid-等待进程改变状态\" class=\"headerlink\" title=\"wait, waitpid, waitid - 等待进程改变状态\"></a>wait, waitpid, waitid - 等待进程改变状态</h2><p>参考：<a href=\"https://man7.org/linux/man-pages/man2/waitpid.2.html\">https://man7.org/linux/man-pages/man2/waitpid.2.html</a></p>\n<h3 id=\"函数原型-9\"><a href=\"#函数原型-9\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span> *wstatus)</span></span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> *wstatus, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">waitid</span><span class=\"params\">(<span class=\"keyword\">idtype_t</span> idtype, <span class=\"keyword\">id_t</span> id, <span class=\"keyword\">siginfo_t</span> *infop, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\">                       <span class=\"comment\">/* 这是glibc和POSIX接口;有关原始系统调用的信息，请参阅NOTES。 */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-5\"><a href=\"#描述-5\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>所有这些 <strong>系统调用</strong> 都是用来等待正在进行的子进程的状态发生变化的，并且获取到子进程状态发生变化的具体信息。</p>\n<p><strong>状态改变</strong> 可以被认为是：</p>\n<ul>\n<li>子进程终止</li>\n<li>子进程被一个信号中断了</li>\n<li>子进程被一个信号恢复了</li>\n</ul>\n<p>在子进程结束的情况下，父进程执行等待可以有效释放子进程的系统资源，如果没有执行等待，那么结束的子进程将以一个“僵尸”状态继续被保留。</p>\n<p>如果一个子进程改变了状态，这些调用将立即返回，否则，它们会阻塞，直到子进程改变状态或信号处理程序中断调用。</p>\n<h4 id=\"wait-和-waitpid\"><a href=\"#wait-和-waitpid\" class=\"headerlink\" title=\"wait 和 waitpid\"></a>wait 和 waitpid</h4><p>wait() <strong>系统调用</strong> 将暂停调用线程的执行，直到它的一个子线程终止。</p>\n<p>函数调用  <em>wait(int *wstatus)</em>  等同于：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">waitpid(<span class=\"number\">-1</span>, &amp;wstatus, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>waitpid <strong>系统调用</strong> 挂起当前调用线程，直到由 <em>pid</em> 参数指定的子进程发生变化。默认情况下，waitpid 只等待终止的子进程，但此行为可以通过修改参数 <em>options</em> 改变。</p>\n<h5 id=\"pid-参数\"><a href=\"#pid-参数\" class=\"headerlink\" title=\"pid 参数\"></a>pid 参数</h5><p><em>pid</em> 的值可以是：</p>\n<ul>\n<li>&lt; -1 　　　　意思是等待任何*进程组 ID 等于 pid 绝对值的子进程</li>\n<li>-1 　　　　　意思是任何子进程</li>\n<li>0 　　　　　意思是等待任何进程组 ID 等于该调用 waitpid 的进程的进程组 ID 的子进程</li>\n<li>&gt; 0 　　　　意思是等待进程 ID 等于 pid 的子进程</li>\n</ul>\n<h5 id=\"options-参数\"><a href=\"#options-参数\" class=\"headerlink\" title=\"options 参数\"></a>options 参数</h5><p><em>options</em> 是一个组合值，包含 0 个或多个一下值：</p>\n<p>WNOHANG： 如果没有孩子死亡则立即返回</p>\n<p>WUNTRACED：</p>\n<p>。。。</p>\n<h3 id=\"返回值-7\"><a href=\"#返回值-7\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><h2 id=\"pipe-pipe2-创建管道（进程间通信）\"><a href=\"#pipe-pipe2-创建管道（进程间通信）\" class=\"headerlink\" title=\"pipe, pipe2 - 创建管道（进程间通信）\"></a>pipe, pipe2 - 创建管道（进程间通信）</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/pipe.2.html\">https://man7.org/linux/man-pages/man2/pipe.2.html</a></p>\n<h3 id=\"函数原型-10\"><a href=\"#函数原型-10\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _GNU_SOURCE             <span class=\"comment\">/* See feature_test_macros(7) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span>              <span class=\"comment\">/* Definition of O_* constants */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe2</span><span class=\"params\">(<span class=\"keyword\">int</span> pipefd[<span class=\"number\">2</span>], <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = pipe(fd);    <span class=\"comment\">// 先</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> pid = fork();    <span class=\"comment\">// 后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">char</span> * str = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(x == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    perror(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i&#x27;m parent\\n&quot;</span>);</span><br><span class=\"line\">    write(fd[<span class=\"number\">1</span>], str, <span class=\"built_in\">strlen</span>(str));</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i am child\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = read(fd[<span class=\"number\">0</span>], buf, <span class=\"number\">1024</span>);</span><br><span class=\"line\">    write(STDOUT_FILENO, buf, ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"描述-6\"><a href=\"#描述-6\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>pipe() 创建一个 <strong>单向</strong> 的可以用于进程间通信的数据通道。 <em>pipefd[]</em> 用来返回两个分别指向管道入端和出端的文件描述符。  <em>pipefd[0]</em> 指的是管道的读端， <em>pipefd[1]</em> 为写端。写入写端的数据会被内核缓冲，直到从读端读取数据，写入的数据只能被读取一次，不能重复读取。  </p>\n<h3 id=\"返回值-8\"><a href=\"#返回值-8\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功时，返回 0</p>\n<p>失败时，返回 -1，设置 errno，并且 <em>pipefd</em> 不会被改变。</p>\n<h2 id=\"mmap-munmap-映射或取消映射文件或设备到内存中（进程间通信）\"><a href=\"#mmap-munmap-映射或取消映射文件或设备到内存中（进程间通信）\" class=\"headerlink\" title=\"mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）\"></a>mmap, munmap - 映射或取消映射文件或设备到内存中（进程间通信）</h2><p>参考： <a href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">https://man7.org/linux/man-pages/man2/mmap.2.html</a></p>\n<h3 id=\"函数原型-11\"><a href=\"#函数原型-11\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> prot, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">           <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span> *addr, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>举例：</p>\n<h3 id=\"描述-7\"><a href=\"#描述-7\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>mmap() 在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址子在 <em>addr</em> 中指定。 <em>length</em> 指定映射的大小（必须大于0）。如果 <em>addr</em> 为NULL，那么内核选择(页面对齐的)地址来创建映射。这种方式创建的 mmap() 具有最好的可移植性。如果 <em>addr</em> 不为NULL，那么内核将其作为放置映射的位置的提示。 <em>offset</em> 必须是内存页（page size = 4096）的整数倍，可以通过 sysconf(_SC_PAGE_SIZE) 的返回值查看。</p>\n<p>文件映射的内容，初始化时使用从文件描述符 <em>fd</em> 引用的文件(或其他对象)的偏移量 <em>offset</em> 处开始的 <em>length</em> 字节大小的映射空间。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/linux-c-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/image-20210822022207629.41lugd2750u0.png\" alt=\"image-20210822022207629\"></p>\n<h4 id=\"prot-参数\"><a href=\"#prot-参数\" class=\"headerlink\" title=\"prot 参数\"></a>prot 参数</h4><p><em>prot</em> 指定映射的内存保护权限。有下面几个宏：</p>\n<ul>\n<li>PROT_EXEC：映射的内存页可以执行</li>\n<li>PROT_READ：映射的内存页可以读</li>\n<li>PROT_WRITE：映射的内存页可以写</li>\n<li>PROT_NONE：映射的内存页不可访问</li>\n</ul>\n<p>可以组合，比如 PROT_READ | PROT_WRITE 。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p><em>flags</em> 参数确定对映射的更新是否对映射同一区域的其他进程可见，以及是否对底层文件进行更新。</p>\n<p>此行为由包含以下值之一确定：</p>\n<ul>\n<li>MAP_SHARED： 分享这个映射。映射的更新对映射同一区域的其它进程是可见的。*并且(在文件支持映射的情况下)将被传递到底层文件。</li>\n<li>MAP_PRIVATE： 创建私有的 <strong>写时拷贝</strong> 映射。</li>\n</ul>\n<p>还能由以下值的零个或多个确定：</p>\n<ul>\n<li>MAP_32BIT</li>\n<li>MAP_ANON</li>\n</ul>\n<p>。。。</p>\n<h3 id=\"返回值-9\"><a href=\"#返回值-9\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>mmap() :</p>\n<p>成功时，返回一个指向映射区域的指针。</p>\n<p>失败时，值 MAP_FAILED （类型为 （void *）-1 ），并设置 errno。</p>\n<p>munmap()：</p>"},{"title":"写给小白看的makefile教程（入门）","date":"2021-08-10T16:44:00.000Z","_content":"\nmakefile类似于shell脚本，它能让terminal执行一系列的命令，在Linux下写c++时，我们可以用到makefile来帮助我们进行预处理、编译、汇编和链接。\n\n下面就来说说如果使用makefile吧~\n\n<!--more-->\n\n## 规则\n\n话不多说，直接上makefile的**一条规则**的语法格式：\n\n```\n目标：依赖\n【Tab键缩进】命令\n```\n\n一条**规则**一共分为**目标**、**依赖**、**Tab缩进**、**命令**四个部分。\n\n**目标：** 是我们希望生产的目标文件\n\n**依赖**： 是我们生产目标文件的源文件（依赖文件）\n\n**Tab缩进：** 语法规则，必须要有\n\n**命令：** 从依赖文件生成目标文件的命令\n\n---\n\n举例子来说明上面的东西：\n\n在当前所工作的目录下创建文件名为makefile的文件即可，比如：\n\n![image-20210810155500869](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155500869.2ymjbwx8roc0.png)\n\n在makefile里面编辑如下：\n![image-20210810155741023](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155741023.59ie1n1juqs0.png)\n\n在terminal中敲入make即可：\n\n![image-20210810155957835](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155957835.3u1sfqagx080.png)\n\n可以看到在敲入make按下回车后，terminal自动帮我执行了 g++ hello.cpp -o hello 这行命令。\n\n回到makefile文件内容：\n![image-20210810160235006](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810160235006.3v4olf8my8g0.png)\n\n在执行make命令时，系统检查到makefile文件中的第一行内容的目标文件为 hello ，为了生成 hello 这个文件它需要一个依赖文件叫 hello.cpp , 此时它检查到当前目录中存在 hello.cpp ， 那么接下来就只需要执行第二行的命令产生目标文件就可以了。\n\n## 原理\n\nmakefile会将它首次遇到的目标文件视为**最终目标文件**，如若生成目标文件的依赖文件不存在，则检查是否有其它规则生成此依赖文件。\n\n---\n\n这句话什么意思呢，让我们再举例子说明一下：\n我们重新编辑makefile文件为：\n\n![image-20210810162235389](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810162235389.6wriil40uug0.png)\n\nmakefile在第一行读到目标文件 hello ， 这是它第一个读到的目标文件，它将这个目标文件视为它需要生成的最终目标文件，生成hello目标文件需要hello.o的依赖文件。\n\n可是当前目录并不存在该文件，于是makefile检查是否还有其它规则来生成该依赖文件，读到第三行的时候，makefile发现了有一个规则能生成hello.o文件。\n\n而生成该hello.o文件的依赖文件为hello.cpp，makefile检查当前目录确实存在hello.cpp文件，于是先执行`g++ -c hello.cpp -o hello.o`生成hello.o，再执行`g++ hello.o -o hello` 生成名为hello的最终目标文件。\n\n---\n\n此时再读这句话我相信你能理解这句话的含义了。\n\n那么，如果我将3、4行和1、2行的内容对调，即：\n\n![image-20210810163145200](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163145200.20oljvyrwleo.png)\n\n会怎么样呢？\n\n按照makefile的原理，它只会生成到hello.o就结束：\n\n![image-20210810163409428](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163409428.3rmndgf17mw0.png)\n\nmakefile肯定有相应的语法来指定这个我们想生成的最终目标文件啦：\n\n![image-20210810163544235](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163544235.5ukrcukyhcc0.png)\n\n但是，此时指定在最末行这行语句会生效吗？\n\n答案是**不会**。\n\nmakefile仍然还是会读取最开始遇到的目标文件视为最终目标文件。\n\n因此，我们将这行指定最终文件的语句放到所有规则的上面，就怎么也不会出问题了：\n\n![image-20210810164013746](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810164013746.3umv04pvueg0.png)\n\n## 函数\n\n### wildcard函数\n\n如下：\n\n```makefile\nsrc = $(wildcard *.cpp)\n```\n\n该函数的作用是获取当前目录下的所有后缀名为.cpp的文件并将其赋值给src，也就是变量src是当前目录下后缀为.cpp文件的集合。\n\n---\n\n举个例子：\n\n在当前目录下\n\n![image-20210815125345013](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210815125345013.1omkhviru8o0.png)\n\n在terminal中输入make，makefile中的 `src = $(wildcard *.cpp)` 会获取到当前目录中后缀为.cpp的文件，在这个例子中，\n\nsrc = [add.cpp ,  main.cpp,  sub.cpp]\n\n#### 文件目录\n\n当然，wildcard函数可以获取任何路径下的某一种后缀名的文件列表。\n\n比如：\n\n```makefile\nsrc = $(wildcard ./src/*.c)\n```\n\n获取当前目录下的src目录下的所有.c后缀的文件列表。\n\n\n\n后缀可以是任何你想要的后缀，目录也可以是任何你想要的目录。下面的所有函数和变量同样可以应用。\n\n### patsubst函数\n\n如下：\n\n```makefile\nobj = $(patsubst %.cpp, %.o, $(src))\n```\n\n如果需要引用变量，只需要在 **$()** 中加入该变量就可以了。\n\n该函数一共有三个参数，第一个参数是需要转换格式的文件列表，第二个参数是想转换成的格式的文件列表，第三个参数是第一个参数的依赖。\n\n---\n\n举例子说明：\n\n在上一个例子中，src = [add.cpp ,  main.cpp,  sub.cpp]，则patsubst函数会将src中所有符合后缀名为.cpp的文件列表获取，用 **%.cpp** 来表示，而将其改为后缀名为 .o 的文件，由 .o 文件构成的文件列表用即为变量 **obj**。\n\n也就是说：\n\nsrc  =  [add.cpp,  main.cpp,  sub.cpp]\n\nobj = [add.o, main.o, sub.o]\n\n## 编译规则\n\n至此，我们简单编译多个c++文件所需要的全部文件名都已经准备好了，接下来就是规则怎么写的问题了。\n\n先看如下语句：\n\n```makefile\nsrc = $(wildcard *.cpp)\nobj = $(patsubst %.cpp, %.o, $(src))\nALL:main\n\nmain:$(obj)\n\tg++ $^ -o $@\n\n$(obj):%.o:%.cpp\n\tg++ -c $< -o $@ \n```\n\n前三行不再解释。\n\n先来解释两个变量， **$^** 表示该规则的依赖， **$@** 表示该规则的目标。\n\n在第五行的规则中， **$^**  表示 **$(obj)** ,  **$@** 表示 **main**。\n\n第六行 `g++ $^ -o $@` 等于 `g++  add.o, main.o, sub.o -o main` 。\n\n\n\n第八行的含义是获取 **$(obj)** 中的后缀为.o的文件，将其作为该规则的目标文件（列表）。\n\n而该目标文件（列表）的依赖则为将 **$(obj)** 中的后缀为.o的文件的后缀.o替换成.cpp的文件（列表）。\n\n**$<** 同样代表依赖，但和 **$^** 不同， **$<** 会遍历依赖中的文件，单个输出。有点像python里面的遍历列表的意思。\n\n也就是说第九行的 `g++ -c $< -o $@ `等于\n\n```\ng++ -c add.cpp -o add.o\ng++ -c main.cpp -o main.o\ng++ -c sub.cpp -o sub.o \n```\n\n## clean函数\n\n当你再次在terminal中输入make命令时，makefile会检查你是否对源文件进行了修改来决定是否需要重新编译部分步骤，如果你没有修改源文件，makefile将不会进行编译，并告诉你：无需做任何事。\n\n如果你需要删除某些文件可以使用makefile的clean函数\n\nmakefile中clean函数格式如下：\n\n```makefile\nclean:\n\t-rm -rf $(obj) main # 可以加入任何你想删除的文件\n```\n\n配置好后，只需在terminal中输入`make clean`即可。\n\n## 结尾\n\n至此，一个初级的makefile文件如下：\n\n```makefile\nsrc = $(wildcard *.cpp)\nobj = $(patsubst %.cpp, %.o, $(src))\n\nALL:main\n\nmain:$(obj)\n\tg++ $^ -o $@\n\n$(obj):%.o:%.cpp\n\tg++ -c $< -o $@\n\nclean:\n\t-rm -rf $(obj) main\n```\n\n希望对你有所帮助。\n","source":"_posts/写给小白看的makefile教程.md","raw":"---\ntitle: 写给小白看的makefile教程（入门）\ndate: 2021-08-10 16:44:00\ncategories: \n  - linux学习\ntags:\n  - linux\n  - c++\n  - c\n  - makefile\n---\n\nmakefile类似于shell脚本，它能让terminal执行一系列的命令，在Linux下写c++时，我们可以用到makefile来帮助我们进行预处理、编译、汇编和链接。\n\n下面就来说说如果使用makefile吧~\n\n<!--more-->\n\n## 规则\n\n话不多说，直接上makefile的**一条规则**的语法格式：\n\n```\n目标：依赖\n【Tab键缩进】命令\n```\n\n一条**规则**一共分为**目标**、**依赖**、**Tab缩进**、**命令**四个部分。\n\n**目标：** 是我们希望生产的目标文件\n\n**依赖**： 是我们生产目标文件的源文件（依赖文件）\n\n**Tab缩进：** 语法规则，必须要有\n\n**命令：** 从依赖文件生成目标文件的命令\n\n---\n\n举例子来说明上面的东西：\n\n在当前所工作的目录下创建文件名为makefile的文件即可，比如：\n\n![image-20210810155500869](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155500869.2ymjbwx8roc0.png)\n\n在makefile里面编辑如下：\n![image-20210810155741023](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155741023.59ie1n1juqs0.png)\n\n在terminal中敲入make即可：\n\n![image-20210810155957835](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810155957835.3u1sfqagx080.png)\n\n可以看到在敲入make按下回车后，terminal自动帮我执行了 g++ hello.cpp -o hello 这行命令。\n\n回到makefile文件内容：\n![image-20210810160235006](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810160235006.3v4olf8my8g0.png)\n\n在执行make命令时，系统检查到makefile文件中的第一行内容的目标文件为 hello ，为了生成 hello 这个文件它需要一个依赖文件叫 hello.cpp , 此时它检查到当前目录中存在 hello.cpp ， 那么接下来就只需要执行第二行的命令产生目标文件就可以了。\n\n## 原理\n\nmakefile会将它首次遇到的目标文件视为**最终目标文件**，如若生成目标文件的依赖文件不存在，则检查是否有其它规则生成此依赖文件。\n\n---\n\n这句话什么意思呢，让我们再举例子说明一下：\n我们重新编辑makefile文件为：\n\n![image-20210810162235389](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810162235389.6wriil40uug0.png)\n\nmakefile在第一行读到目标文件 hello ， 这是它第一个读到的目标文件，它将这个目标文件视为它需要生成的最终目标文件，生成hello目标文件需要hello.o的依赖文件。\n\n可是当前目录并不存在该文件，于是makefile检查是否还有其它规则来生成该依赖文件，读到第三行的时候，makefile发现了有一个规则能生成hello.o文件。\n\n而生成该hello.o文件的依赖文件为hello.cpp，makefile检查当前目录确实存在hello.cpp文件，于是先执行`g++ -c hello.cpp -o hello.o`生成hello.o，再执行`g++ hello.o -o hello` 生成名为hello的最终目标文件。\n\n---\n\n此时再读这句话我相信你能理解这句话的含义了。\n\n那么，如果我将3、4行和1、2行的内容对调，即：\n\n![image-20210810163145200](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163145200.20oljvyrwleo.png)\n\n会怎么样呢？\n\n按照makefile的原理，它只会生成到hello.o就结束：\n\n![image-20210810163409428](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163409428.3rmndgf17mw0.png)\n\nmakefile肯定有相应的语法来指定这个我们想生成的最终目标文件啦：\n\n![image-20210810163544235](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810163544235.5ukrcukyhcc0.png)\n\n但是，此时指定在最末行这行语句会生效吗？\n\n答案是**不会**。\n\nmakefile仍然还是会读取最开始遇到的目标文件视为最终目标文件。\n\n因此，我们将这行指定最终文件的语句放到所有规则的上面，就怎么也不会出问题了：\n\n![image-20210810164013746](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210810164013746.3umv04pvueg0.png)\n\n## 函数\n\n### wildcard函数\n\n如下：\n\n```makefile\nsrc = $(wildcard *.cpp)\n```\n\n该函数的作用是获取当前目录下的所有后缀名为.cpp的文件并将其赋值给src，也就是变量src是当前目录下后缀为.cpp文件的集合。\n\n---\n\n举个例子：\n\n在当前目录下\n\n![image-20210815125345013](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/makefile入门教程/image-20210815125345013.1omkhviru8o0.png)\n\n在terminal中输入make，makefile中的 `src = $(wildcard *.cpp)` 会获取到当前目录中后缀为.cpp的文件，在这个例子中，\n\nsrc = [add.cpp ,  main.cpp,  sub.cpp]\n\n#### 文件目录\n\n当然，wildcard函数可以获取任何路径下的某一种后缀名的文件列表。\n\n比如：\n\n```makefile\nsrc = $(wildcard ./src/*.c)\n```\n\n获取当前目录下的src目录下的所有.c后缀的文件列表。\n\n\n\n后缀可以是任何你想要的后缀，目录也可以是任何你想要的目录。下面的所有函数和变量同样可以应用。\n\n### patsubst函数\n\n如下：\n\n```makefile\nobj = $(patsubst %.cpp, %.o, $(src))\n```\n\n如果需要引用变量，只需要在 **$()** 中加入该变量就可以了。\n\n该函数一共有三个参数，第一个参数是需要转换格式的文件列表，第二个参数是想转换成的格式的文件列表，第三个参数是第一个参数的依赖。\n\n---\n\n举例子说明：\n\n在上一个例子中，src = [add.cpp ,  main.cpp,  sub.cpp]，则patsubst函数会将src中所有符合后缀名为.cpp的文件列表获取，用 **%.cpp** 来表示，而将其改为后缀名为 .o 的文件，由 .o 文件构成的文件列表用即为变量 **obj**。\n\n也就是说：\n\nsrc  =  [add.cpp,  main.cpp,  sub.cpp]\n\nobj = [add.o, main.o, sub.o]\n\n## 编译规则\n\n至此，我们简单编译多个c++文件所需要的全部文件名都已经准备好了，接下来就是规则怎么写的问题了。\n\n先看如下语句：\n\n```makefile\nsrc = $(wildcard *.cpp)\nobj = $(patsubst %.cpp, %.o, $(src))\nALL:main\n\nmain:$(obj)\n\tg++ $^ -o $@\n\n$(obj):%.o:%.cpp\n\tg++ -c $< -o $@ \n```\n\n前三行不再解释。\n\n先来解释两个变量， **$^** 表示该规则的依赖， **$@** 表示该规则的目标。\n\n在第五行的规则中， **$^**  表示 **$(obj)** ,  **$@** 表示 **main**。\n\n第六行 `g++ $^ -o $@` 等于 `g++  add.o, main.o, sub.o -o main` 。\n\n\n\n第八行的含义是获取 **$(obj)** 中的后缀为.o的文件，将其作为该规则的目标文件（列表）。\n\n而该目标文件（列表）的依赖则为将 **$(obj)** 中的后缀为.o的文件的后缀.o替换成.cpp的文件（列表）。\n\n**$<** 同样代表依赖，但和 **$^** 不同， **$<** 会遍历依赖中的文件，单个输出。有点像python里面的遍历列表的意思。\n\n也就是说第九行的 `g++ -c $< -o $@ `等于\n\n```\ng++ -c add.cpp -o add.o\ng++ -c main.cpp -o main.o\ng++ -c sub.cpp -o sub.o \n```\n\n## clean函数\n\n当你再次在terminal中输入make命令时，makefile会检查你是否对源文件进行了修改来决定是否需要重新编译部分步骤，如果你没有修改源文件，makefile将不会进行编译，并告诉你：无需做任何事。\n\n如果你需要删除某些文件可以使用makefile的clean函数\n\nmakefile中clean函数格式如下：\n\n```makefile\nclean:\n\t-rm -rf $(obj) main # 可以加入任何你想删除的文件\n```\n\n配置好后，只需在terminal中输入`make clean`即可。\n\n## 结尾\n\n至此，一个初级的makefile文件如下：\n\n```makefile\nsrc = $(wildcard *.cpp)\nobj = $(patsubst %.cpp, %.o, $(src))\n\nALL:main\n\nmain:$(obj)\n\tg++ $^ -o $@\n\n$(obj):%.o:%.cpp\n\tg++ -c $< -o $@\n\nclean:\n\t-rm -rf $(obj) main\n```\n\n希望对你有所帮助。\n","slug":"写给小白看的makefile教程","published":1,"updated":"2022-04-05T18:17:16.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1mhhtd100039icb1i384niy","content":"<p>makefile类似于shell脚本，它能让terminal执行一系列的命令，在Linux下写c++时，我们可以用到makefile来帮助我们进行预处理、编译、汇编和链接。</p>\n<p>下面就来说说如果使用makefile吧~</p>\n<span id=\"more\"></span>\n\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><p>话不多说，直接上makefile的<strong>一条规则</strong>的语法格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标：依赖</span><br><span class=\"line\">【Tab键缩进】命令</span><br></pre></td></tr></table></figure>\n\n<p>一条<strong>规则</strong>一共分为<strong>目标</strong>、<strong>依赖</strong>、<strong>Tab缩进</strong>、<strong>命令</strong>四个部分。</p>\n<p><strong>目标：</strong> 是我们希望生产的目标文件</p>\n<p><strong>依赖</strong>： 是我们生产目标文件的源文件（依赖文件）</p>\n<p><strong>Tab缩进：</strong> 语法规则，必须要有</p>\n<p><strong>命令：</strong> 从依赖文件生成目标文件的命令</p>\n<hr>\n<p>举例子来说明上面的东西：</p>\n<p>在当前所工作的目录下创建文件名为makefile的文件即可，比如：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155500869.2ymjbwx8roc0.png\" alt=\"image-20210810155500869\"></p>\n<p>在makefile里面编辑如下：<br><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155741023.59ie1n1juqs0.png\" alt=\"image-20210810155741023\"></p>\n<p>在terminal中敲入make即可：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155957835.3u1sfqagx080.png\" alt=\"image-20210810155957835\"></p>\n<p>可以看到在敲入make按下回车后，terminal自动帮我执行了 g++ hello.cpp -o hello 这行命令。</p>\n<p>回到makefile文件内容：<br><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810160235006.3v4olf8my8g0.png\" alt=\"image-20210810160235006\"></p>\n<p>在执行make命令时，系统检查到makefile文件中的第一行内容的目标文件为 hello ，为了生成 hello 这个文件它需要一个依赖文件叫 hello.cpp , 此时它检查到当前目录中存在 hello.cpp ， 那么接下来就只需要执行第二行的命令产生目标文件就可以了。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>makefile会将它首次遇到的目标文件视为<strong>最终目标文件</strong>，如若生成目标文件的依赖文件不存在，则检查是否有其它规则生成此依赖文件。</p>\n<hr>\n<p>这句话什么意思呢，让我们再举例子说明一下：<br>我们重新编辑makefile文件为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810162235389.6wriil40uug0.png\" alt=\"image-20210810162235389\"></p>\n<p>makefile在第一行读到目标文件 hello ， 这是它第一个读到的目标文件，它将这个目标文件视为它需要生成的最终目标文件，生成hello目标文件需要hello.o的依赖文件。</p>\n<p>可是当前目录并不存在该文件，于是makefile检查是否还有其它规则来生成该依赖文件，读到第三行的时候，makefile发现了有一个规则能生成hello.o文件。</p>\n<p>而生成该hello.o文件的依赖文件为hello.cpp，makefile检查当前目录确实存在hello.cpp文件，于是先执行<code>g++ -c hello.cpp -o hello.o</code>生成hello.o，再执行<code>g++ hello.o -o hello</code> 生成名为hello的最终目标文件。</p>\n<hr>\n<p>此时再读这句话我相信你能理解这句话的含义了。</p>\n<p>那么，如果我将3、4行和1、2行的内容对调，即：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163145200.20oljvyrwleo.png\" alt=\"image-20210810163145200\"></p>\n<p>会怎么样呢？</p>\n<p>按照makefile的原理，它只会生成到hello.o就结束：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163409428.3rmndgf17mw0.png\" alt=\"image-20210810163409428\"></p>\n<p>makefile肯定有相应的语法来指定这个我们想生成的最终目标文件啦：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163544235.5ukrcukyhcc0.png\" alt=\"image-20210810163544235\"></p>\n<p>但是，此时指定在最末行这行语句会生效吗？</p>\n<p>答案是<strong>不会</strong>。</p>\n<p>makefile仍然还是会读取最开始遇到的目标文件视为最终目标文件。</p>\n<p>因此，我们将这行指定最终文件的语句放到所有规则的上面，就怎么也不会出问题了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810164013746.3umv04pvueg0.png\" alt=\"image-20210810164013746\"></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"wildcard函数\"><a href=\"#wildcard函数\" class=\"headerlink\" title=\"wildcard函数\"></a>wildcard函数</h3><p>如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br></pre></td></tr></table></figure>\n\n<p>该函数的作用是获取当前目录下的所有后缀名为.cpp的文件并将其赋值给src，也就是变量src是当前目录下后缀为.cpp文件的集合。</p>\n<hr>\n<p>举个例子：</p>\n<p>在当前目录下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210815125345013.1omkhviru8o0.png\" alt=\"image-20210815125345013\"></p>\n<p>在terminal中输入make，makefile中的 <code>src = $(wildcard *.cpp)</code> 会获取到当前目录中后缀为.cpp的文件，在这个例子中，</p>\n<p>src = [add.cpp ,  main.cpp,  sub.cpp]</p>\n<h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><p>当然，wildcard函数可以获取任何路径下的某一种后缀名的文件列表。</p>\n<p>比如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> ./src/*.c)</span></span><br></pre></td></tr></table></figure>\n\n<p>获取当前目录下的src目录下的所有.c后缀的文件列表。</p>\n<p>后缀可以是任何你想要的后缀，目录也可以是任何你想要的目录。下面的所有函数和变量同样可以应用。</p>\n<h3 id=\"patsubst函数\"><a href=\"#patsubst函数\" class=\"headerlink\" title=\"patsubst函数\"></a>patsubst函数</h3><p>如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要引用变量，只需要在 <strong>$()</strong> 中加入该变量就可以了。</p>\n<p>该函数一共有三个参数，第一个参数是需要转换格式的文件列表，第二个参数是想转换成的格式的文件列表，第三个参数是第一个参数的依赖。</p>\n<hr>\n<p>举例子说明：</p>\n<p>在上一个例子中，src = [add.cpp ,  main.cpp,  sub.cpp]，则patsubst函数会将src中所有符合后缀名为.cpp的文件列表获取，用 <strong>%.cpp</strong> 来表示，而将其改为后缀名为 .o 的文件，由 .o 文件构成的文件列表用即为变量 <strong>obj</strong>。</p>\n<p>也就是说：</p>\n<p>src  =  [add.cpp,  main.cpp,  sub.cpp]</p>\n<p>obj = [add.o, main.o, sub.o]</p>\n<h2 id=\"编译规则\"><a href=\"#编译规则\" class=\"headerlink\" title=\"编译规则\"></a>编译规则</h2><p>至此，我们简单编译多个c++文件所需要的全部文件名都已经准备好了，接下来就是规则怎么写的问题了。</p>\n<p>先看如下语句：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br><span class=\"line\"><span class=\"section\">ALL:main</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">main:<span class=\"variable\">$(obj)</span></span></span><br><span class=\"line\">\tg++ <span class=\"variable\">$^</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(obj)</span>:%.o:%.cpp</span><br><span class=\"line\">\tg++ -c <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span> </span><br></pre></td></tr></table></figure>\n\n<p>前三行不再解释。</p>\n<p>先来解释两个变量， <strong>$^</strong> 表示该规则的依赖， <strong>$@</strong> 表示该规则的目标。</p>\n<p>在第五行的规则中， <strong>$^</strong>  表示 <strong>$(obj)</strong> ,  <strong>$@</strong> 表示 <strong>main</strong>。</p>\n<p>第六行 <code>g++ $^ -o $@</code> 等于 <code>g++  add.o, main.o, sub.o -o main</code> 。</p>\n<p>第八行的含义是获取 <strong>$(obj)</strong> 中的后缀为.o的文件，将其作为该规则的目标文件（列表）。</p>\n<p>而该目标文件（列表）的依赖则为将 <strong>$(obj)</strong> 中的后缀为.o的文件的后缀.o替换成.cpp的文件（列表）。</p>\n<p><strong>$&lt;</strong> 同样代表依赖，但和 <strong>$^</strong> 不同， <strong>$&lt;</strong> 会遍历依赖中的文件，单个输出。有点像python里面的遍历列表的意思。</p>\n<p>也就是说第九行的 <code>g++ -c $&lt; -o $@ </code>等于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -c add.cpp -o add.o</span><br><span class=\"line\">g++ -c main.cpp -o main.o</span><br><span class=\"line\">g++ -c sub.cpp -o sub.o </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"clean函数\"><a href=\"#clean函数\" class=\"headerlink\" title=\"clean函数\"></a>clean函数</h2><p>当你再次在terminal中输入make命令时，makefile会检查你是否对源文件进行了修改来决定是否需要重新编译部分步骤，如果你没有修改源文件，makefile将不会进行编译，并告诉你：无需做任何事。</p>\n<p>如果你需要删除某些文件可以使用makefile的clean函数</p>\n<p>makefile中clean函数格式如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t-rm -rf <span class=\"variable\">$(obj)</span> main <span class=\"comment\"># 可以加入任何你想删除的文件</span></span><br></pre></td></tr></table></figure>\n\n<p>配置好后，只需在terminal中输入<code>make clean</code>即可。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>至此，一个初级的makefile文件如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">ALL:main</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">main:<span class=\"variable\">$(obj)</span></span></span><br><span class=\"line\">\tg++ <span class=\"variable\">$^</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(obj)</span>:%.o:%.cpp</span><br><span class=\"line\">\tg++ -c <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t-rm -rf <span class=\"variable\">$(obj)</span> main</span><br></pre></td></tr></table></figure>\n\n<p>希望对你有所帮助。</p>\n","site":{"data":{}},"excerpt":"<p>makefile类似于shell脚本，它能让terminal执行一系列的命令，在Linux下写c++时，我们可以用到makefile来帮助我们进行预处理、编译、汇编和链接。</p>\n<p>下面就来说说如果使用makefile吧~</p>","more":"<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><p>话不多说，直接上makefile的<strong>一条规则</strong>的语法格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标：依赖</span><br><span class=\"line\">【Tab键缩进】命令</span><br></pre></td></tr></table></figure>\n\n<p>一条<strong>规则</strong>一共分为<strong>目标</strong>、<strong>依赖</strong>、<strong>Tab缩进</strong>、<strong>命令</strong>四个部分。</p>\n<p><strong>目标：</strong> 是我们希望生产的目标文件</p>\n<p><strong>依赖</strong>： 是我们生产目标文件的源文件（依赖文件）</p>\n<p><strong>Tab缩进：</strong> 语法规则，必须要有</p>\n<p><strong>命令：</strong> 从依赖文件生成目标文件的命令</p>\n<hr>\n<p>举例子来说明上面的东西：</p>\n<p>在当前所工作的目录下创建文件名为makefile的文件即可，比如：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155500869.2ymjbwx8roc0.png\" alt=\"image-20210810155500869\"></p>\n<p>在makefile里面编辑如下：<br><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155741023.59ie1n1juqs0.png\" alt=\"image-20210810155741023\"></p>\n<p>在terminal中敲入make即可：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810155957835.3u1sfqagx080.png\" alt=\"image-20210810155957835\"></p>\n<p>可以看到在敲入make按下回车后，terminal自动帮我执行了 g++ hello.cpp -o hello 这行命令。</p>\n<p>回到makefile文件内容：<br><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810160235006.3v4olf8my8g0.png\" alt=\"image-20210810160235006\"></p>\n<p>在执行make命令时，系统检查到makefile文件中的第一行内容的目标文件为 hello ，为了生成 hello 这个文件它需要一个依赖文件叫 hello.cpp , 此时它检查到当前目录中存在 hello.cpp ， 那么接下来就只需要执行第二行的命令产生目标文件就可以了。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>makefile会将它首次遇到的目标文件视为<strong>最终目标文件</strong>，如若生成目标文件的依赖文件不存在，则检查是否有其它规则生成此依赖文件。</p>\n<hr>\n<p>这句话什么意思呢，让我们再举例子说明一下：<br>我们重新编辑makefile文件为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810162235389.6wriil40uug0.png\" alt=\"image-20210810162235389\"></p>\n<p>makefile在第一行读到目标文件 hello ， 这是它第一个读到的目标文件，它将这个目标文件视为它需要生成的最终目标文件，生成hello目标文件需要hello.o的依赖文件。</p>\n<p>可是当前目录并不存在该文件，于是makefile检查是否还有其它规则来生成该依赖文件，读到第三行的时候，makefile发现了有一个规则能生成hello.o文件。</p>\n<p>而生成该hello.o文件的依赖文件为hello.cpp，makefile检查当前目录确实存在hello.cpp文件，于是先执行<code>g++ -c hello.cpp -o hello.o</code>生成hello.o，再执行<code>g++ hello.o -o hello</code> 生成名为hello的最终目标文件。</p>\n<hr>\n<p>此时再读这句话我相信你能理解这句话的含义了。</p>\n<p>那么，如果我将3、4行和1、2行的内容对调，即：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163145200.20oljvyrwleo.png\" alt=\"image-20210810163145200\"></p>\n<p>会怎么样呢？</p>\n<p>按照makefile的原理，它只会生成到hello.o就结束：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163409428.3rmndgf17mw0.png\" alt=\"image-20210810163409428\"></p>\n<p>makefile肯定有相应的语法来指定这个我们想生成的最终目标文件啦：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810163544235.5ukrcukyhcc0.png\" alt=\"image-20210810163544235\"></p>\n<p>但是，此时指定在最末行这行语句会生效吗？</p>\n<p>答案是<strong>不会</strong>。</p>\n<p>makefile仍然还是会读取最开始遇到的目标文件视为最终目标文件。</p>\n<p>因此，我们将这行指定最终文件的语句放到所有规则的上面，就怎么也不会出问题了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210810164013746.3umv04pvueg0.png\" alt=\"image-20210810164013746\"></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"wildcard函数\"><a href=\"#wildcard函数\" class=\"headerlink\" title=\"wildcard函数\"></a>wildcard函数</h3><p>如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br></pre></td></tr></table></figure>\n\n<p>该函数的作用是获取当前目录下的所有后缀名为.cpp的文件并将其赋值给src，也就是变量src是当前目录下后缀为.cpp文件的集合。</p>\n<hr>\n<p>举个例子：</p>\n<p>在当前目录下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image-20210815125345013.1omkhviru8o0.png\" alt=\"image-20210815125345013\"></p>\n<p>在terminal中输入make，makefile中的 <code>src = $(wildcard *.cpp)</code> 会获取到当前目录中后缀为.cpp的文件，在这个例子中，</p>\n<p>src = [add.cpp ,  main.cpp,  sub.cpp]</p>\n<h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><p>当然，wildcard函数可以获取任何路径下的某一种后缀名的文件列表。</p>\n<p>比如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> ./src/*.c)</span></span><br></pre></td></tr></table></figure>\n\n<p>获取当前目录下的src目录下的所有.c后缀的文件列表。</p>\n<p>后缀可以是任何你想要的后缀，目录也可以是任何你想要的目录。下面的所有函数和变量同样可以应用。</p>\n<h3 id=\"patsubst函数\"><a href=\"#patsubst函数\" class=\"headerlink\" title=\"patsubst函数\"></a>patsubst函数</h3><p>如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要引用变量，只需要在 <strong>$()</strong> 中加入该变量就可以了。</p>\n<p>该函数一共有三个参数，第一个参数是需要转换格式的文件列表，第二个参数是想转换成的格式的文件列表，第三个参数是第一个参数的依赖。</p>\n<hr>\n<p>举例子说明：</p>\n<p>在上一个例子中，src = [add.cpp ,  main.cpp,  sub.cpp]，则patsubst函数会将src中所有符合后缀名为.cpp的文件列表获取，用 <strong>%.cpp</strong> 来表示，而将其改为后缀名为 .o 的文件，由 .o 文件构成的文件列表用即为变量 <strong>obj</strong>。</p>\n<p>也就是说：</p>\n<p>src  =  [add.cpp,  main.cpp,  sub.cpp]</p>\n<p>obj = [add.o, main.o, sub.o]</p>\n<h2 id=\"编译规则\"><a href=\"#编译规则\" class=\"headerlink\" title=\"编译规则\"></a>编译规则</h2><p>至此，我们简单编译多个c++文件所需要的全部文件名都已经准备好了，接下来就是规则怎么写的问题了。</p>\n<p>先看如下语句：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br><span class=\"line\"><span class=\"section\">ALL:main</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">main:<span class=\"variable\">$(obj)</span></span></span><br><span class=\"line\">\tg++ <span class=\"variable\">$^</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(obj)</span>:%.o:%.cpp</span><br><span class=\"line\">\tg++ -c <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span> </span><br></pre></td></tr></table></figure>\n\n<p>前三行不再解释。</p>\n<p>先来解释两个变量， <strong>$^</strong> 表示该规则的依赖， <strong>$@</strong> 表示该规则的目标。</p>\n<p>在第五行的规则中， <strong>$^</strong>  表示 <strong>$(obj)</strong> ,  <strong>$@</strong> 表示 <strong>main</strong>。</p>\n<p>第六行 <code>g++ $^ -o $@</code> 等于 <code>g++  add.o, main.o, sub.o -o main</code> 。</p>\n<p>第八行的含义是获取 <strong>$(obj)</strong> 中的后缀为.o的文件，将其作为该规则的目标文件（列表）。</p>\n<p>而该目标文件（列表）的依赖则为将 <strong>$(obj)</strong> 中的后缀为.o的文件的后缀.o替换成.cpp的文件（列表）。</p>\n<p><strong>$&lt;</strong> 同样代表依赖，但和 <strong>$^</strong> 不同， <strong>$&lt;</strong> 会遍历依赖中的文件，单个输出。有点像python里面的遍历列表的意思。</p>\n<p>也就是说第九行的 <code>g++ -c $&lt; -o $@ </code>等于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -c add.cpp -o add.o</span><br><span class=\"line\">g++ -c main.cpp -o main.o</span><br><span class=\"line\">g++ -c sub.cpp -o sub.o </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"clean函数\"><a href=\"#clean函数\" class=\"headerlink\" title=\"clean函数\"></a>clean函数</h2><p>当你再次在terminal中输入make命令时，makefile会检查你是否对源文件进行了修改来决定是否需要重新编译部分步骤，如果你没有修改源文件，makefile将不会进行编译，并告诉你：无需做任何事。</p>\n<p>如果你需要删除某些文件可以使用makefile的clean函数</p>\n<p>makefile中clean函数格式如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t-rm -rf <span class=\"variable\">$(obj)</span> main <span class=\"comment\"># 可以加入任何你想删除的文件</span></span><br></pre></td></tr></table></figure>\n\n<p>配置好后，只需在terminal中输入<code>make clean</code>即可。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>至此，一个初级的makefile文件如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src = <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> *.cpp)</span></span><br><span class=\"line\">obj = <span class=\"variable\">$(<span class=\"built_in\">patsubst</span> %.cpp, %.o, <span class=\"variable\">$(src)</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">ALL:main</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">main:<span class=\"variable\">$(obj)</span></span></span><br><span class=\"line\">\tg++ <span class=\"variable\">$^</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(obj)</span>:%.o:%.cpp</span><br><span class=\"line\">\tg++ -c <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t-rm -rf <span class=\"variable\">$(obj)</span> main</span><br></pre></td></tr></table></figure>\n\n<p>希望对你有所帮助。</p>"},{"title":"VLAN 技术学习总结","date":"2022-04-09T03:59:31.000Z","mathjax":true,"_content":"\n## VLAN技术学习总结\n\n### 基本概念\n\n虚拟局域网技术（Virtual Local Area Network 简写 VLAN）将一个**交换式LAN**划分成多个相互独立的虚拟物理网络，这些逻辑上虚拟的物理网络称为VLAN，每一个VLAN就是一个广播域，不同VLAN之间在逻辑上相互隔离，不同VLAN成员不能在二层直接通信，VLAN之间的通信只能通过三层或者更高层实现。\n\n划分VLAN是为了隔离广播域，其标准为IEEE 802.1Q。\n\n### VLAN标识符\n\n一个VLAN由一个VLAN ID（VLAN Identifier）唯一标识。VLAN ID 简写 VID。\n\nVID值由一个12比特的无符号数表示，其理论有效范围为 1 到 4096 （$2^{12}$)，具体设备支持的VID范围可能更小。\n\n默认VID值为1，用户不能指派他用。当没有划分VLAN时，所有站点都属于VLAN1，通常VLAN 1作为管理VLAN使用。当然，默认VLAN ID可以进行更改，不一定非要是1。\n\n### VLAN设备\n\nVLAN设备类型分为 VLAN知晓设备 和 VLAN非知晓设备。\n\n#### VLAN知晓设备 （VLAN aware）\n\n能意识到VLAN的存在。\n\n识别VLAN加标帧（802.1Q帧）并予以处理，同时也能处理非加标帧（基本MAC帧）。\n\nVLAN知晓设备通常是：支持VLAN协议的交换机 或者 支持VLAN协议的服务器。\n\n#### VLAN非知晓设备（VLAN unaware）\n\n不能意识到VLAN的存在。\n\n不能识别VLAN加标帧。\n\nVLAN知晓设备可以是：不支持VLAN协议的交换机（其对VLAN加标帧按照基本MAC帧进行处理） 或者 普通PC机（其不能识别加标帧，将直接丢弃加标帧）。\n\n### VLAN链路\n\nVLAN不同链路对应不同端口。VLAN链路包括 **主干链路（Trunk Link）**、**接入链路（Access Link）**、**混合链路（Hybrid Link）**。其对应的端口分别为 **Trunk Port**、**Access Port**、**Hybrid Port**。\n\n**Trunk**\n\nTrunk Link 通常用于互连VLAN知晓设备。Trunk Port 是连接 Trunk Link 的两端口，Trunk Port收发VLAN加标帧。一个Trunk Port可以同时属于多个VLAN（这有什么好处？我们后面讲）。\n\n**Access**\n\nAccess Link通常用于（VLAN知晓设备）将非知晓设备接入VLAN。Access Port 是VLAN**知晓**设备上连接Access Link的端口。（注意这里是VLAN知晓设备的端口，而不像之前Trunk是两端口都是Trunk Port）。\n\nAccess Port只能收发无标识帧。\n\n![image_2022-04-01_22-41-55](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-01_22-41-55.5l49rq23j9s0.png)\n\n**Hybrid**\n\nHybrid Link能同时连接VLAN知晓设备和VLAN非知晓设备。Hybrid Port 可以接收**不同**VLAN的帧为它们带上对应的 Tag，也能**发送**不同VLAN带上Tag的帧或者是不同VLAN不带Tag的帧。\n\n这张[图](https://www.utepo.net/article/detail/251.html)可以方便理解Hybrid Link和Port\n\n![image_2022-04-01_21-21-03](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-01_21-21-03.3pwinylpm1s0.png)\n\n蓝色端口被配置为Hybrid Port，其下的不同的VLAN发送帧到达这个端口时，Hybrid Port根据不同帧给它们打上不同的Tag。而Hybrid Port向下发送帧时，可以根据配置给某些VLAN发送带Tag的帧，给某些VLAN发送不带Tag的帧。\n\nHybrid Port的存在主要是为VLAN知晓设备的一个转发端口接到不同VLAN里面而存在的。\n\n下层的VLAN由于受限集线器（Hub）的存在并未实现隔离广播域的效果。\n\nHybrid和Trunk Port都能同时配置多个VLAN，Hybrid Link通常使用共享链路，而Trunk Link使用点到点全双工链路。\n\n### VLAN帧格式\n\nVLAN帧和以太网基本MAC帧的唯一不同在于VLAN帧有一个4字节的Tag部分。下图中未标注单位均为字节。\n\n![image_2022-04-09_00-42-32](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_00-42-32.1l22noqh4n6o.png)\n\n**TPID：**标签协议标识符（Tag Protocol Identifier），用以标识加标帧的类型，802.1Q Tag帧取值固定为0x8100，极VLAN协议\n\n**P：**优先级（Priority）。0~7共8个等级，优先级高的帧先发出。不同设备支持优先级的等级数有差异。\n\n**CFI：**标准格式指示位（Canonical Format Indicator），表示MAC地址是否是经典格式。CFI为0说明是标准格式，CFI为1表示为非标准格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。\n\n**VLAN ID：**VLAN Identifier，有效值0~4095。\n\n0：VLAN ID = null，该帧为用户优先级帧（仅使用优先级P的功能），非VLAN加标帧。\n\n1：默认VLAN ID，该默认VLAN ID可以改变成不是1的数字。\n\n4095：保留。\n\n所以VLAN ID的有效范围：1~4094。\n\n#### 注意\n\nVLAN加标帧允许的最长帧大小超过基本MAC帧长的1518字节，其最长能允许1522（1518+4）字节，而最小帧长字节与基本MAC帧最小帧长相同，均为64字节。\n\n值得注意的是，以上帧格式是802.1Q的封装格式，而思科交换机使用的是其专有协议**[ISL](https://www.cisco.com/c/zh_cn/support/docs/lan-switching/8021q/17056-741-4.html)**，此种封装只能在思科设备间使用，若在组网时使用了思科还有其他品牌的设备一定要注意把思科交换机的VLAN封装格式更换成802.1Q封装！\n\n我之前就在组网的时候遇到了这个问题，琢磨半天也想不出问题在哪里，最后发现是思科交换机的VLAN帧封装的问题。。\n\n在思科交换机中开启802.1Q封装解决问题：\n\n``` Switch(config-if)#switchport trunk encapsulation dot1q ```\n\n![image_2022-04-09_01-25-22](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_01-25-22.5oixo0nq2h4.webp)\n\n对于上面的802.1Q封装，VLAN支持三种帧类型。\n\n无标帧，即基本MAC帧\n\n优先级加标帧，无有效VID的802.1Q帧\n\nVLAN加标帧，既有优先级又有有效VID的802.1Q帧\n\n### 再谈Trunk Link\n\n为什么一个Trunk Port要同时属于多个VLAN？\n\n事实上，在不使用Trunk的情况下，VLAN也完全可以实现，甚至在这种情况下实现路由功能的设备（可以是三层交换机也可以是路由器）可以是VLAN非知晓设备。\n\n具体拓扑如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-02-37.1ke1r07mwyjk.webp\" alt=\"image_2022-04-09_02-02-37\" style=\"zoom:50%;\" />\n\n这种情况下，有多少个VLAN就需要L2 SW和L3 SW之间有多少个连接线，显然没有必要这样做，Trunk Link使得L2 SW和L3 SW之间只需要一条线。\n\n![image_2022-04-09_02-09-24](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-09-24.40bymf2gl540.webp)\n\n### VLAN间通信案例\n\n下面结合Packet Tracer来实现VLAN间通信的仿真。\n\n拓扑如下\n\n![image_2022-04-09_02-30-29](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-30-29.60kvzdtufb00.webp)\n\n网关和ip地址在每台PC上静态配置。\n\n此时VLAN10内的PC可以互ping，VLAN20内的设备可以互ping，又因为双方不在同一个子网规划下，且此时L3 SW未绑定它俩的网关ip地址，VLAN10和VLAN20不能互ping。（注意此时只是配置了四台PC的ip和网关，VLAN什么的还没有配置）。\n\n![IMG_0964(20220409-025615)](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/IMG_0964(20220409-025615).mj9eh85qyls.webp)\n\n接下来配置L2 SW（access port）\n\n```\nSwitch>enable \nSwitch#config t\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 10 \nSwitch(config-vlan)#exit \nSwitch(config)#vlan 20\nSwitch(config-vlan)#exit\nSwitch(config)#int f0/1 \nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#int f0/3\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#int f0/2\nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 20\nSwitch(config-if)#exit\nSwitch(config)#int f0/4\nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 20\nSwitch(config-if)#exit\n```\n\nshow vlan 检测配置\n\n``` \nSwitch#show vlan\n\nVLAN Name                             Status    Ports\n---- -------------------------------- --------- -------------------------------\n10   VLAN0010                         active    Fa0/1, Fa0/3\n20   VLAN0020                         active    Fa0/2, Fa0/4\n```\n\n接下来配置trunk port，此时需要配置L2 SW的 f0/5 和 L3 SW的 f0/1\n\n配置L2 SW f0/5\n\n```\nSwitch(config)#int f0/5\nSwitch(config-if)#switchport mode trunk \n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\n```\n\n配置L3 SW f0/1\n\n```\nSwitch(config)#int f0/1\nSwitch(config-if)#switchport mode trunk\nCommand rejected: An interface whose trunk encapsulation is \"Auto\" can not be configured to \"trunk\" mode.\n# 没有指定端口的VLAN封装类型\nSwitch(config-if)#switchport trunk encapsulation dot1q #指定为802.1Q封装\nSwitch(config-if)#switchport mode trunk #设置端口为Trunk Port\nSwitch(config-if)#exit\nSwitch(config)#vlan 10\nSwitch(config-vlan)#exit\nSwitch(config)#vlan 20\nSwitch(config-vlan)#exit\nSwitch(config)#int vlan 10\nSwitch(config-if)#\n%LINK-5-CHANGED: Interface Vlan10, changed state to up\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan10, changed state to up\n\nSwitch(config-if)#ip address 192.168.10.254 255.255.255.0\nSwitch(config-if)#int vlan 20\nSwitch(config-if)#\n%LINK-5-CHANGED: Interface Vlan20, changed state to up\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to up\n\nSwitch(config-if)#ip address 192.168.20.254 255.255.255.0\nSwitch(config-if)#exit\nSwitch(config)#\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\n\nSwitch#show ip route \nDefault gateway is not set\n\nHost               Gateway           Last Use    Total Uses  Interface\nICMP redirect cache is empty\n\t\nSwitch#config t\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#ip routing #开启路由\nSwitch(config)#exit\nSwitch#show ip route \nCodes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP\n       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area\n       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2\n       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP\n       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area\n       * - candidate default, U - per-user static route, o - ODR\n       P - periodic downloaded static route\n\nGateway of last resort is not set\n\nC    192.168.10.0/24 is directly connected, Vlan10\nC    192.168.20.0/24 is directly connected, Vlan20\n```\n\n此时PC1 ping PC2\n\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_03-28-53.50wbrt7hwfg0.webp\" alt=\"image_2022-04-09_03-28-53\" style=\"zoom:50%;\" />\n\n可以看到已经通了。\n\n#### PC1 ping PC2的数据包追踪流程图\n\n![IMG_0965(20220409-035030)](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/IMG_0965(20220409-035030).6amubcp68rs0.PNG)\n","source":"_posts/vlan-技术学习总结.md","raw":"---\ntitle: VLAN 技术学习总结\ndate: 2022-04-09 03:59:31\ntags:\nmathjax: true\n---\n\n## VLAN技术学习总结\n\n### 基本概念\n\n虚拟局域网技术（Virtual Local Area Network 简写 VLAN）将一个**交换式LAN**划分成多个相互独立的虚拟物理网络，这些逻辑上虚拟的物理网络称为VLAN，每一个VLAN就是一个广播域，不同VLAN之间在逻辑上相互隔离，不同VLAN成员不能在二层直接通信，VLAN之间的通信只能通过三层或者更高层实现。\n\n划分VLAN是为了隔离广播域，其标准为IEEE 802.1Q。\n\n### VLAN标识符\n\n一个VLAN由一个VLAN ID（VLAN Identifier）唯一标识。VLAN ID 简写 VID。\n\nVID值由一个12比特的无符号数表示，其理论有效范围为 1 到 4096 （$2^{12}$)，具体设备支持的VID范围可能更小。\n\n默认VID值为1，用户不能指派他用。当没有划分VLAN时，所有站点都属于VLAN1，通常VLAN 1作为管理VLAN使用。当然，默认VLAN ID可以进行更改，不一定非要是1。\n\n### VLAN设备\n\nVLAN设备类型分为 VLAN知晓设备 和 VLAN非知晓设备。\n\n#### VLAN知晓设备 （VLAN aware）\n\n能意识到VLAN的存在。\n\n识别VLAN加标帧（802.1Q帧）并予以处理，同时也能处理非加标帧（基本MAC帧）。\n\nVLAN知晓设备通常是：支持VLAN协议的交换机 或者 支持VLAN协议的服务器。\n\n#### VLAN非知晓设备（VLAN unaware）\n\n不能意识到VLAN的存在。\n\n不能识别VLAN加标帧。\n\nVLAN知晓设备可以是：不支持VLAN协议的交换机（其对VLAN加标帧按照基本MAC帧进行处理） 或者 普通PC机（其不能识别加标帧，将直接丢弃加标帧）。\n\n### VLAN链路\n\nVLAN不同链路对应不同端口。VLAN链路包括 **主干链路（Trunk Link）**、**接入链路（Access Link）**、**混合链路（Hybrid Link）**。其对应的端口分别为 **Trunk Port**、**Access Port**、**Hybrid Port**。\n\n**Trunk**\n\nTrunk Link 通常用于互连VLAN知晓设备。Trunk Port 是连接 Trunk Link 的两端口，Trunk Port收发VLAN加标帧。一个Trunk Port可以同时属于多个VLAN（这有什么好处？我们后面讲）。\n\n**Access**\n\nAccess Link通常用于（VLAN知晓设备）将非知晓设备接入VLAN。Access Port 是VLAN**知晓**设备上连接Access Link的端口。（注意这里是VLAN知晓设备的端口，而不像之前Trunk是两端口都是Trunk Port）。\n\nAccess Port只能收发无标识帧。\n\n![image_2022-04-01_22-41-55](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-01_22-41-55.5l49rq23j9s0.png)\n\n**Hybrid**\n\nHybrid Link能同时连接VLAN知晓设备和VLAN非知晓设备。Hybrid Port 可以接收**不同**VLAN的帧为它们带上对应的 Tag，也能**发送**不同VLAN带上Tag的帧或者是不同VLAN不带Tag的帧。\n\n这张[图](https://www.utepo.net/article/detail/251.html)可以方便理解Hybrid Link和Port\n\n![image_2022-04-01_21-21-03](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-01_21-21-03.3pwinylpm1s0.png)\n\n蓝色端口被配置为Hybrid Port，其下的不同的VLAN发送帧到达这个端口时，Hybrid Port根据不同帧给它们打上不同的Tag。而Hybrid Port向下发送帧时，可以根据配置给某些VLAN发送带Tag的帧，给某些VLAN发送不带Tag的帧。\n\nHybrid Port的存在主要是为VLAN知晓设备的一个转发端口接到不同VLAN里面而存在的。\n\n下层的VLAN由于受限集线器（Hub）的存在并未实现隔离广播域的效果。\n\nHybrid和Trunk Port都能同时配置多个VLAN，Hybrid Link通常使用共享链路，而Trunk Link使用点到点全双工链路。\n\n### VLAN帧格式\n\nVLAN帧和以太网基本MAC帧的唯一不同在于VLAN帧有一个4字节的Tag部分。下图中未标注单位均为字节。\n\n![image_2022-04-09_00-42-32](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_00-42-32.1l22noqh4n6o.png)\n\n**TPID：**标签协议标识符（Tag Protocol Identifier），用以标识加标帧的类型，802.1Q Tag帧取值固定为0x8100，极VLAN协议\n\n**P：**优先级（Priority）。0~7共8个等级，优先级高的帧先发出。不同设备支持优先级的等级数有差异。\n\n**CFI：**标准格式指示位（Canonical Format Indicator），表示MAC地址是否是经典格式。CFI为0说明是标准格式，CFI为1表示为非标准格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。\n\n**VLAN ID：**VLAN Identifier，有效值0~4095。\n\n0：VLAN ID = null，该帧为用户优先级帧（仅使用优先级P的功能），非VLAN加标帧。\n\n1：默认VLAN ID，该默认VLAN ID可以改变成不是1的数字。\n\n4095：保留。\n\n所以VLAN ID的有效范围：1~4094。\n\n#### 注意\n\nVLAN加标帧允许的最长帧大小超过基本MAC帧长的1518字节，其最长能允许1522（1518+4）字节，而最小帧长字节与基本MAC帧最小帧长相同，均为64字节。\n\n值得注意的是，以上帧格式是802.1Q的封装格式，而思科交换机使用的是其专有协议**[ISL](https://www.cisco.com/c/zh_cn/support/docs/lan-switching/8021q/17056-741-4.html)**，此种封装只能在思科设备间使用，若在组网时使用了思科还有其他品牌的设备一定要注意把思科交换机的VLAN封装格式更换成802.1Q封装！\n\n我之前就在组网的时候遇到了这个问题，琢磨半天也想不出问题在哪里，最后发现是思科交换机的VLAN帧封装的问题。。\n\n在思科交换机中开启802.1Q封装解决问题：\n\n``` Switch(config-if)#switchport trunk encapsulation dot1q ```\n\n![image_2022-04-09_01-25-22](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_01-25-22.5oixo0nq2h4.webp)\n\n对于上面的802.1Q封装，VLAN支持三种帧类型。\n\n无标帧，即基本MAC帧\n\n优先级加标帧，无有效VID的802.1Q帧\n\nVLAN加标帧，既有优先级又有有效VID的802.1Q帧\n\n### 再谈Trunk Link\n\n为什么一个Trunk Port要同时属于多个VLAN？\n\n事实上，在不使用Trunk的情况下，VLAN也完全可以实现，甚至在这种情况下实现路由功能的设备（可以是三层交换机也可以是路由器）可以是VLAN非知晓设备。\n\n具体拓扑如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-02-37.1ke1r07mwyjk.webp\" alt=\"image_2022-04-09_02-02-37\" style=\"zoom:50%;\" />\n\n这种情况下，有多少个VLAN就需要L2 SW和L3 SW之间有多少个连接线，显然没有必要这样做，Trunk Link使得L2 SW和L3 SW之间只需要一条线。\n\n![image_2022-04-09_02-09-24](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-09-24.40bymf2gl540.webp)\n\n### VLAN间通信案例\n\n下面结合Packet Tracer来实现VLAN间通信的仿真。\n\n拓扑如下\n\n![image_2022-04-09_02-30-29](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-30-29.60kvzdtufb00.webp)\n\n网关和ip地址在每台PC上静态配置。\n\n此时VLAN10内的PC可以互ping，VLAN20内的设备可以互ping，又因为双方不在同一个子网规划下，且此时L3 SW未绑定它俩的网关ip地址，VLAN10和VLAN20不能互ping。（注意此时只是配置了四台PC的ip和网关，VLAN什么的还没有配置）。\n\n![IMG_0964(20220409-025615)](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/IMG_0964(20220409-025615).mj9eh85qyls.webp)\n\n接下来配置L2 SW（access port）\n\n```\nSwitch>enable \nSwitch#config t\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#vlan 10 \nSwitch(config-vlan)#exit \nSwitch(config)#vlan 20\nSwitch(config-vlan)#exit\nSwitch(config)#int f0/1 \nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#int f0/3\nSwitch(config-if)#switchport mode access\nSwitch(config-if)#switchport access vlan 10\nSwitch(config-if)#exit\nSwitch(config)#int f0/2\nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 20\nSwitch(config-if)#exit\nSwitch(config)#int f0/4\nSwitch(config-if)#switchport mode access \nSwitch(config-if)#switchport access vlan 20\nSwitch(config-if)#exit\n```\n\nshow vlan 检测配置\n\n``` \nSwitch#show vlan\n\nVLAN Name                             Status    Ports\n---- -------------------------------- --------- -------------------------------\n10   VLAN0010                         active    Fa0/1, Fa0/3\n20   VLAN0020                         active    Fa0/2, Fa0/4\n```\n\n接下来配置trunk port，此时需要配置L2 SW的 f0/5 和 L3 SW的 f0/1\n\n配置L2 SW f0/5\n\n```\nSwitch(config)#int f0/5\nSwitch(config-if)#switchport mode trunk \n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up\n```\n\n配置L3 SW f0/1\n\n```\nSwitch(config)#int f0/1\nSwitch(config-if)#switchport mode trunk\nCommand rejected: An interface whose trunk encapsulation is \"Auto\" can not be configured to \"trunk\" mode.\n# 没有指定端口的VLAN封装类型\nSwitch(config-if)#switchport trunk encapsulation dot1q #指定为802.1Q封装\nSwitch(config-if)#switchport mode trunk #设置端口为Trunk Port\nSwitch(config-if)#exit\nSwitch(config)#vlan 10\nSwitch(config-vlan)#exit\nSwitch(config)#vlan 20\nSwitch(config-vlan)#exit\nSwitch(config)#int vlan 10\nSwitch(config-if)#\n%LINK-5-CHANGED: Interface Vlan10, changed state to up\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan10, changed state to up\n\nSwitch(config-if)#ip address 192.168.10.254 255.255.255.0\nSwitch(config-if)#int vlan 20\nSwitch(config-if)#\n%LINK-5-CHANGED: Interface Vlan20, changed state to up\n\n%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to up\n\nSwitch(config-if)#ip address 192.168.20.254 255.255.255.0\nSwitch(config-if)#exit\nSwitch(config)#\nSwitch#\n%SYS-5-CONFIG_I: Configured from console by console\n\nSwitch#show ip route \nDefault gateway is not set\n\nHost               Gateway           Last Use    Total Uses  Interface\nICMP redirect cache is empty\n\t\nSwitch#config t\nEnter configuration commands, one per line.  End with CNTL/Z.\nSwitch(config)#ip routing #开启路由\nSwitch(config)#exit\nSwitch#show ip route \nCodes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP\n       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area\n       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2\n       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP\n       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area\n       * - candidate default, U - per-user static route, o - ODR\n       P - periodic downloaded static route\n\nGateway of last resort is not set\n\nC    192.168.10.0/24 is directly connected, Vlan10\nC    192.168.20.0/24 is directly connected, Vlan20\n```\n\n此时PC1 ping PC2\n\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_03-28-53.50wbrt7hwfg0.webp\" alt=\"image_2022-04-09_03-28-53\" style=\"zoom:50%;\" />\n\n可以看到已经通了。\n\n#### PC1 ping PC2的数据包追踪流程图\n\n![IMG_0965(20220409-035030)](https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/IMG_0965(20220409-035030).6amubcp68rs0.PNG)\n","slug":"vlan-技术学习总结","published":1,"updated":"2022-04-08T20:12:48.099Z","_id":"cl1qus1rt00002zjj8caa6s5w","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"VLAN技术学习总结\"><a href=\"#VLAN技术学习总结\" class=\"headerlink\" title=\"VLAN技术学习总结\"></a>VLAN技术学习总结</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>虚拟局域网技术（Virtual Local Area Network 简写 VLAN）将一个<strong>交换式LAN</strong>划分成多个相互独立的虚拟物理网络，这些逻辑上虚拟的物理网络称为VLAN，每一个VLAN就是一个广播域，不同VLAN之间在逻辑上相互隔离，不同VLAN成员不能在二层直接通信，VLAN之间的通信只能通过三层或者更高层实现。</p>\n<p>划分VLAN是为了隔离广播域，其标准为IEEE 802.1Q。</p>\n<h3 id=\"VLAN标识符\"><a href=\"#VLAN标识符\" class=\"headerlink\" title=\"VLAN标识符\"></a>VLAN标识符</h3><p>一个VLAN由一个VLAN ID（VLAN Identifier）唯一标识。VLAN ID 简写 VID。</p>\n<p>VID值由一个12比特的无符号数表示，其理论有效范围为 1 到 4096 （$2^{12}$)，具体设备支持的VID范围可能更小。</p>\n<p>默认VID值为1，用户不能指派他用。当没有划分VLAN时，所有站点都属于VLAN1，通常VLAN 1作为管理VLAN使用。当然，默认VLAN ID可以进行更改，不一定非要是1。</p>\n<h3 id=\"VLAN设备\"><a href=\"#VLAN设备\" class=\"headerlink\" title=\"VLAN设备\"></a>VLAN设备</h3><p>VLAN设备类型分为 VLAN知晓设备 和 VLAN非知晓设备。</p>\n<h4 id=\"VLAN知晓设备-（VLAN-aware）\"><a href=\"#VLAN知晓设备-（VLAN-aware）\" class=\"headerlink\" title=\"VLAN知晓设备 （VLAN aware）\"></a>VLAN知晓设备 （VLAN aware）</h4><p>能意识到VLAN的存在。</p>\n<p>识别VLAN加标帧（802.1Q帧）并予以处理，同时也能处理非加标帧（基本MAC帧）。</p>\n<p>VLAN知晓设备通常是：支持VLAN协议的交换机 或者 支持VLAN协议的服务器。</p>\n<h4 id=\"VLAN非知晓设备（VLAN-unaware）\"><a href=\"#VLAN非知晓设备（VLAN-unaware）\" class=\"headerlink\" title=\"VLAN非知晓设备（VLAN unaware）\"></a>VLAN非知晓设备（VLAN unaware）</h4><p>不能意识到VLAN的存在。</p>\n<p>不能识别VLAN加标帧。</p>\n<p>VLAN知晓设备可以是：不支持VLAN协议的交换机（其对VLAN加标帧按照基本MAC帧进行处理） 或者 普通PC机（其不能识别加标帧，将直接丢弃加标帧）。</p>\n<h3 id=\"VLAN链路\"><a href=\"#VLAN链路\" class=\"headerlink\" title=\"VLAN链路\"></a>VLAN链路</h3><p>VLAN不同链路对应不同端口。VLAN链路包括 <strong>主干链路（Trunk Link）</strong>、<strong>接入链路（Access Link）</strong>、<strong>混合链路（Hybrid Link）</strong>。其对应的端口分别为 <strong>Trunk Port</strong>、<strong>Access Port</strong>、<strong>Hybrid Port</strong>。</p>\n<p><strong>Trunk</strong></p>\n<p>Trunk Link 通常用于互连VLAN知晓设备。Trunk Port 是连接 Trunk Link 的两端口，Trunk Port收发VLAN加标帧。一个Trunk Port可以同时属于多个VLAN（这有什么好处？我们后面讲）。</p>\n<p><strong>Access</strong></p>\n<p>Access Link通常用于（VLAN知晓设备）将非知晓设备接入VLAN。Access Port 是VLAN<strong>知晓</strong>设备上连接Access Link的端口。（注意这里是VLAN知晓设备的端口，而不像之前Trunk是两端口都是Trunk Port）。</p>\n<p>Access Port只能收发无标识帧。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-01_22-41-55.5l49rq23j9s0.png\" alt=\"image_2022-04-01_22-41-55\"></p>\n<p><strong>Hybrid</strong></p>\n<p>Hybrid Link能同时连接VLAN知晓设备和VLAN非知晓设备。Hybrid Port 可以接收<strong>不同</strong>VLAN的帧为它们带上对应的 Tag，也能<strong>发送</strong>不同VLAN带上Tag的帧或者是不同VLAN不带Tag的帧。</p>\n<p>这张<a href=\"https://www.utepo.net/article/detail/251.html\">图</a>可以方便理解Hybrid Link和Port</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-01_21-21-03.3pwinylpm1s0.png\" alt=\"image_2022-04-01_21-21-03\"></p>\n<p>蓝色端口被配置为Hybrid Port，其下的不同的VLAN发送帧到达这个端口时，Hybrid Port根据不同帧给它们打上不同的Tag。而Hybrid Port向下发送帧时，可以根据配置给某些VLAN发送带Tag的帧，给某些VLAN发送不带Tag的帧。</p>\n<p>Hybrid Port的存在主要是为VLAN知晓设备的一个转发端口接到不同VLAN里面而存在的。</p>\n<p>下层的VLAN由于受限集线器（Hub）的存在并未实现隔离广播域的效果。</p>\n<p>Hybrid和Trunk Port都能同时配置多个VLAN，Hybrid Link通常使用共享链路，而Trunk Link使用点到点全双工链路。</p>\n<h3 id=\"VLAN帧格式\"><a href=\"#VLAN帧格式\" class=\"headerlink\" title=\"VLAN帧格式\"></a>VLAN帧格式</h3><p>VLAN帧和以太网基本MAC帧的唯一不同在于VLAN帧有一个4字节的Tag部分。下图中未标注单位均为字节。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_00-42-32.1l22noqh4n6o.png\" alt=\"image_2022-04-09_00-42-32\"></p>\n<p><strong>TPID：</strong>标签协议标识符（Tag Protocol Identifier），用以标识加标帧的类型，802.1Q Tag帧取值固定为0x8100，极VLAN协议</p>\n<p><strong>P：</strong>优先级（Priority）。0~7共8个等级，优先级高的帧先发出。不同设备支持优先级的等级数有差异。</p>\n<p><strong>CFI：</strong>标准格式指示位（Canonical Format Indicator），表示MAC地址是否是经典格式。CFI为0说明是标准格式，CFI为1表示为非标准格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。</p>\n<p><strong>VLAN ID：</strong>VLAN Identifier，有效值0~4095。</p>\n<p>0：VLAN ID = null，该帧为用户优先级帧（仅使用优先级P的功能），非VLAN加标帧。</p>\n<p>1：默认VLAN ID，该默认VLAN ID可以改变成不是1的数字。</p>\n<p>4095：保留。</p>\n<p>所以VLAN ID的有效范围：1~4094。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>VLAN加标帧允许的最长帧大小超过基本MAC帧长的1518字节，其最长能允许1522（1518+4）字节，而最小帧长字节与基本MAC帧最小帧长相同，均为64字节。</p>\n<p>值得注意的是，以上帧格式是802.1Q的封装格式，而思科交换机使用的是其专有协议**<a href=\"https://www.cisco.com/c/zh_cn/support/docs/lan-switching/8021q/17056-741-4.html\">ISL</a>**，此种封装只能在思科设备间使用，若在组网时使用了思科还有其他品牌的设备一定要注意把思科交换机的VLAN封装格式更换成802.1Q封装！</p>\n<p>我之前就在组网的时候遇到了这个问题，琢磨半天也想不出问题在哪里，最后发现是思科交换机的VLAN帧封装的问题。。</p>\n<p>在思科交换机中开启802.1Q封装解决问题：</p>\n<p><code>Switch(config-if)#switchport trunk encapsulation dot1q</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_01-25-22.5oixo0nq2h4.webp\" alt=\"image_2022-04-09_01-25-22\"></p>\n<p>对于上面的802.1Q封装，VLAN支持三种帧类型。</p>\n<p>无标帧，即基本MAC帧</p>\n<p>优先级加标帧，无有效VID的802.1Q帧</p>\n<p>VLAN加标帧，既有优先级又有有效VID的802.1Q帧</p>\n<h3 id=\"再谈Trunk-Link\"><a href=\"#再谈Trunk-Link\" class=\"headerlink\" title=\"再谈Trunk Link\"></a>再谈Trunk Link</h3><p>为什么一个Trunk Port要同时属于多个VLAN？</p>\n<p>事实上，在不使用Trunk的情况下，VLAN也完全可以实现，甚至在这种情况下实现路由功能的设备（可以是三层交换机也可以是路由器）可以是VLAN非知晓设备。</p>\n<p>具体拓扑如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-02-37.1ke1r07mwyjk.webp\" alt=\"image_2022-04-09_02-02-37\" style=\"zoom:50%;\" />\n\n<p>这种情况下，有多少个VLAN就需要L2 SW和L3 SW之间有多少个连接线，显然没有必要这样做，Trunk Link使得L2 SW和L3 SW之间只需要一条线。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_02-09-24.40bymf2gl540.webp\" alt=\"image_2022-04-09_02-09-24\"></p>\n<h3 id=\"VLAN间通信案例\"><a href=\"#VLAN间通信案例\" class=\"headerlink\" title=\"VLAN间通信案例\"></a>VLAN间通信案例</h3><p>下面结合Packet Tracer来实现VLAN间通信的仿真。</p>\n<p>拓扑如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_02-30-29.60kvzdtufb00.webp\" alt=\"image_2022-04-09_02-30-29\"></p>\n<p>网关和ip地址在每台PC上静态配置。</p>\n<p>此时VLAN10内的PC可以互ping，VLAN20内的设备可以互ping，又因为双方不在同一个子网规划下，且此时L3 SW未绑定它俩的网关ip地址，VLAN10和VLAN20不能互ping。（注意此时只是配置了四台PC的ip和网关，VLAN什么的还没有配置）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG_0964(20220409-025615).mj9eh85qyls.webp\" alt=\"IMG_0964(20220409-025615)\"></p>\n<p>接下来配置L2 SW（access port）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch&gt;enable </span><br><span class=\"line\">Switch#config t</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Switch(config)#vlan 10 </span><br><span class=\"line\">Switch(config-vlan)#exit </span><br><span class=\"line\">Switch(config)#vlan 20</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#int f0/1 </span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 10</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/3</span><br><span class=\"line\">Switch(config-if)#switchport mode access</span><br><span class=\"line\">Switch(config-if)#switchport access vlan 10</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/2</span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 20</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/4</span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 20</span><br><span class=\"line\">Switch(config-if)#exit</span><br></pre></td></tr></table></figure>\n\n<p>show vlan 检测配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch#show vlan</span><br><span class=\"line\"></span><br><span class=\"line\">VLAN Name                             Status    Ports</span><br><span class=\"line\">---- -------------------------------- --------- -------------------------------</span><br><span class=\"line\">10   VLAN0010                         active    Fa0/1, Fa0/3</span><br><span class=\"line\">20   VLAN0020                         active    Fa0/2, Fa0/4</span><br></pre></td></tr></table></figure>\n\n<p>接下来配置trunk port，此时需要配置L2 SW的 f0/5 和 L3 SW的 f0/1</p>\n<p>配置L2 SW f0/5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch(config)#int f0/5</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk </span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up</span><br></pre></td></tr></table></figure>\n\n<p>配置L3 SW f0/1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch(config)#int f0/1</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk</span><br><span class=\"line\">Command rejected: An interface whose trunk encapsulation is &quot;Auto&quot; can not be configured to &quot;trunk&quot; mode.</span><br><span class=\"line\"># 没有指定端口的VLAN封装类型</span><br><span class=\"line\">Switch(config-if)#switchport trunk encapsulation dot1q #指定为802.1Q封装</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk #设置端口为Trunk Port</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#vlan 10</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#vlan 20</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#int vlan 10</span><br><span class=\"line\">Switch(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface Vlan10, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan10, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(config-if)#ip address 192.168.10.254 255.255.255.0</span><br><span class=\"line\">Switch(config-if)#int vlan 20</span><br><span class=\"line\">Switch(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface Vlan20, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(config-if)#ip address 192.168.20.254 255.255.255.0</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#</span><br><span class=\"line\">Switch#</span><br><span class=\"line\">%SYS-5-CONFIG_I: Configured from console by console</span><br><span class=\"line\"></span><br><span class=\"line\">Switch#show ip route </span><br><span class=\"line\">Default gateway is not set</span><br><span class=\"line\"></span><br><span class=\"line\">Host               Gateway           Last Use    Total Uses  Interface</span><br><span class=\"line\">ICMP redirect cache is empty</span><br><span class=\"line\">\t</span><br><span class=\"line\">Switch#config t</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Switch(config)#ip routing #开启路由</span><br><span class=\"line\">Switch(config)#exit</span><br><span class=\"line\">Switch#show ip route </span><br><span class=\"line\">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class=\"line\">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class=\"line\">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class=\"line\">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class=\"line\">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class=\"line\">       * - candidate default, U - per-user static route, o - ODR</span><br><span class=\"line\">       P - periodic downloaded static route</span><br><span class=\"line\"></span><br><span class=\"line\">Gateway of last resort is not set</span><br><span class=\"line\"></span><br><span class=\"line\">C    192.168.10.0/24 is directly connected, Vlan10</span><br><span class=\"line\">C    192.168.20.0/24 is directly connected, Vlan20</span><br></pre></td></tr></table></figure>\n\n<p>此时PC1 ping PC2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_03-28-53.50wbrt7hwfg0.webp\" alt=\"image_2022-04-09_03-28-53\" style=\"zoom:50%;\" />\n\n<p>可以看到已经通了。</p>\n<h4 id=\"PC1-ping-PC2的数据包追踪流程图\"><a href=\"#PC1-ping-PC2的数据包追踪流程图\" class=\"headerlink\" title=\"PC1 ping PC2的数据包追踪流程图\"></a>PC1 ping PC2的数据包追踪流程图</h4><p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG_0965(20220409-035030).6amubcp68rs0.PNG\" alt=\"IMG_0965(20220409-035030)\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"VLAN技术学习总结\"><a href=\"#VLAN技术学习总结\" class=\"headerlink\" title=\"VLAN技术学习总结\"></a>VLAN技术学习总结</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>虚拟局域网技术（Virtual Local Area Network 简写 VLAN）将一个<strong>交换式LAN</strong>划分成多个相互独立的虚拟物理网络，这些逻辑上虚拟的物理网络称为VLAN，每一个VLAN就是一个广播域，不同VLAN之间在逻辑上相互隔离，不同VLAN成员不能在二层直接通信，VLAN之间的通信只能通过三层或者更高层实现。</p>\n<p>划分VLAN是为了隔离广播域，其标准为IEEE 802.1Q。</p>\n<h3 id=\"VLAN标识符\"><a href=\"#VLAN标识符\" class=\"headerlink\" title=\"VLAN标识符\"></a>VLAN标识符</h3><p>一个VLAN由一个VLAN ID（VLAN Identifier）唯一标识。VLAN ID 简写 VID。</p>\n<p>VID值由一个12比特的无符号数表示，其理论有效范围为 1 到 4096 （$2^{12}$)，具体设备支持的VID范围可能更小。</p>\n<p>默认VID值为1，用户不能指派他用。当没有划分VLAN时，所有站点都属于VLAN1，通常VLAN 1作为管理VLAN使用。当然，默认VLAN ID可以进行更改，不一定非要是1。</p>\n<h3 id=\"VLAN设备\"><a href=\"#VLAN设备\" class=\"headerlink\" title=\"VLAN设备\"></a>VLAN设备</h3><p>VLAN设备类型分为 VLAN知晓设备 和 VLAN非知晓设备。</p>\n<h4 id=\"VLAN知晓设备-（VLAN-aware）\"><a href=\"#VLAN知晓设备-（VLAN-aware）\" class=\"headerlink\" title=\"VLAN知晓设备 （VLAN aware）\"></a>VLAN知晓设备 （VLAN aware）</h4><p>能意识到VLAN的存在。</p>\n<p>识别VLAN加标帧（802.1Q帧）并予以处理，同时也能处理非加标帧（基本MAC帧）。</p>\n<p>VLAN知晓设备通常是：支持VLAN协议的交换机 或者 支持VLAN协议的服务器。</p>\n<h4 id=\"VLAN非知晓设备（VLAN-unaware）\"><a href=\"#VLAN非知晓设备（VLAN-unaware）\" class=\"headerlink\" title=\"VLAN非知晓设备（VLAN unaware）\"></a>VLAN非知晓设备（VLAN unaware）</h4><p>不能意识到VLAN的存在。</p>\n<p>不能识别VLAN加标帧。</p>\n<p>VLAN知晓设备可以是：不支持VLAN协议的交换机（其对VLAN加标帧按照基本MAC帧进行处理） 或者 普通PC机（其不能识别加标帧，将直接丢弃加标帧）。</p>\n<h3 id=\"VLAN链路\"><a href=\"#VLAN链路\" class=\"headerlink\" title=\"VLAN链路\"></a>VLAN链路</h3><p>VLAN不同链路对应不同端口。VLAN链路包括 <strong>主干链路（Trunk Link）</strong>、<strong>接入链路（Access Link）</strong>、<strong>混合链路（Hybrid Link）</strong>。其对应的端口分别为 <strong>Trunk Port</strong>、<strong>Access Port</strong>、<strong>Hybrid Port</strong>。</p>\n<p><strong>Trunk</strong></p>\n<p>Trunk Link 通常用于互连VLAN知晓设备。Trunk Port 是连接 Trunk Link 的两端口，Trunk Port收发VLAN加标帧。一个Trunk Port可以同时属于多个VLAN（这有什么好处？我们后面讲）。</p>\n<p><strong>Access</strong></p>\n<p>Access Link通常用于（VLAN知晓设备）将非知晓设备接入VLAN。Access Port 是VLAN<strong>知晓</strong>设备上连接Access Link的端口。（注意这里是VLAN知晓设备的端口，而不像之前Trunk是两端口都是Trunk Port）。</p>\n<p>Access Port只能收发无标识帧。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-01_22-41-55.5l49rq23j9s0.png\" alt=\"image_2022-04-01_22-41-55\"></p>\n<p><strong>Hybrid</strong></p>\n<p>Hybrid Link能同时连接VLAN知晓设备和VLAN非知晓设备。Hybrid Port 可以接收<strong>不同</strong>VLAN的帧为它们带上对应的 Tag，也能<strong>发送</strong>不同VLAN带上Tag的帧或者是不同VLAN不带Tag的帧。</p>\n<p>这张<a href=\"https://www.utepo.net/article/detail/251.html\">图</a>可以方便理解Hybrid Link和Port</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-01_21-21-03.3pwinylpm1s0.png\" alt=\"image_2022-04-01_21-21-03\"></p>\n<p>蓝色端口被配置为Hybrid Port，其下的不同的VLAN发送帧到达这个端口时，Hybrid Port根据不同帧给它们打上不同的Tag。而Hybrid Port向下发送帧时，可以根据配置给某些VLAN发送带Tag的帧，给某些VLAN发送不带Tag的帧。</p>\n<p>Hybrid Port的存在主要是为VLAN知晓设备的一个转发端口接到不同VLAN里面而存在的。</p>\n<p>下层的VLAN由于受限集线器（Hub）的存在并未实现隔离广播域的效果。</p>\n<p>Hybrid和Trunk Port都能同时配置多个VLAN，Hybrid Link通常使用共享链路，而Trunk Link使用点到点全双工链路。</p>\n<h3 id=\"VLAN帧格式\"><a href=\"#VLAN帧格式\" class=\"headerlink\" title=\"VLAN帧格式\"></a>VLAN帧格式</h3><p>VLAN帧和以太网基本MAC帧的唯一不同在于VLAN帧有一个4字节的Tag部分。下图中未标注单位均为字节。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_00-42-32.1l22noqh4n6o.png\" alt=\"image_2022-04-09_00-42-32\"></p>\n<p><strong>TPID：</strong>标签协议标识符（Tag Protocol Identifier），用以标识加标帧的类型，802.1Q Tag帧取值固定为0x8100，极VLAN协议</p>\n<p><strong>P：</strong>优先级（Priority）。0~7共8个等级，优先级高的帧先发出。不同设备支持优先级的等级数有差异。</p>\n<p><strong>CFI：</strong>标准格式指示位（Canonical Format Indicator），表示MAC地址是否是经典格式。CFI为0说明是标准格式，CFI为1表示为非标准格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。</p>\n<p><strong>VLAN ID：</strong>VLAN Identifier，有效值0~4095。</p>\n<p>0：VLAN ID = null，该帧为用户优先级帧（仅使用优先级P的功能），非VLAN加标帧。</p>\n<p>1：默认VLAN ID，该默认VLAN ID可以改变成不是1的数字。</p>\n<p>4095：保留。</p>\n<p>所以VLAN ID的有效范围：1~4094。</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>VLAN加标帧允许的最长帧大小超过基本MAC帧长的1518字节，其最长能允许1522（1518+4）字节，而最小帧长字节与基本MAC帧最小帧长相同，均为64字节。</p>\n<p>值得注意的是，以上帧格式是802.1Q的封装格式，而思科交换机使用的是其专有协议**<a href=\"https://www.cisco.com/c/zh_cn/support/docs/lan-switching/8021q/17056-741-4.html\">ISL</a>**，此种封装只能在思科设备间使用，若在组网时使用了思科还有其他品牌的设备一定要注意把思科交换机的VLAN封装格式更换成802.1Q封装！</p>\n<p>我之前就在组网的时候遇到了这个问题，琢磨半天也想不出问题在哪里，最后发现是思科交换机的VLAN帧封装的问题。。</p>\n<p>在思科交换机中开启802.1Q封装解决问题：</p>\n<p><code>Switch(config-if)#switchport trunk encapsulation dot1q</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_01-25-22.5oixo0nq2h4.webp\" alt=\"image_2022-04-09_01-25-22\"></p>\n<p>对于上面的802.1Q封装，VLAN支持三种帧类型。</p>\n<p>无标帧，即基本MAC帧</p>\n<p>优先级加标帧，无有效VID的802.1Q帧</p>\n<p>VLAN加标帧，既有优先级又有有效VID的802.1Q帧</p>\n<h3 id=\"再谈Trunk-Link\"><a href=\"#再谈Trunk-Link\" class=\"headerlink\" title=\"再谈Trunk Link\"></a>再谈Trunk Link</h3><p>为什么一个Trunk Port要同时属于多个VLAN？</p>\n<p>事实上，在不使用Trunk的情况下，VLAN也完全可以实现，甚至在这种情况下实现路由功能的设备（可以是三层交换机也可以是路由器）可以是VLAN非知晓设备。</p>\n<p>具体拓扑如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_02-02-37.1ke1r07mwyjk.webp\" alt=\"image_2022-04-09_02-02-37\" style=\"zoom:50%;\" />\n\n<p>这种情况下，有多少个VLAN就需要L2 SW和L3 SW之间有多少个连接线，显然没有必要这样做，Trunk Link使得L2 SW和L3 SW之间只需要一条线。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_02-09-24.40bymf2gl540.webp\" alt=\"image_2022-04-09_02-09-24\"></p>\n<h3 id=\"VLAN间通信案例\"><a href=\"#VLAN间通信案例\" class=\"headerlink\" title=\"VLAN间通信案例\"></a>VLAN间通信案例</h3><p>下面结合Packet Tracer来实现VLAN间通信的仿真。</p>\n<p>拓扑如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image_2022-04-09_02-30-29.60kvzdtufb00.webp\" alt=\"image_2022-04-09_02-30-29\"></p>\n<p>网关和ip地址在每台PC上静态配置。</p>\n<p>此时VLAN10内的PC可以互ping，VLAN20内的设备可以互ping，又因为双方不在同一个子网规划下，且此时L3 SW未绑定它俩的网关ip地址，VLAN10和VLAN20不能互ping。（注意此时只是配置了四台PC的ip和网关，VLAN什么的还没有配置）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG_0964(20220409-025615).mj9eh85qyls.webp\" alt=\"IMG_0964(20220409-025615)\"></p>\n<p>接下来配置L2 SW（access port）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch&gt;enable </span><br><span class=\"line\">Switch#config t</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Switch(config)#vlan 10 </span><br><span class=\"line\">Switch(config-vlan)#exit </span><br><span class=\"line\">Switch(config)#vlan 20</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#int f0/1 </span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 10</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/3</span><br><span class=\"line\">Switch(config-if)#switchport mode access</span><br><span class=\"line\">Switch(config-if)#switchport access vlan 10</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/2</span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 20</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#int f0/4</span><br><span class=\"line\">Switch(config-if)#switchport mode access </span><br><span class=\"line\">Switch(config-if)#switchport access vlan 20</span><br><span class=\"line\">Switch(config-if)#exit</span><br></pre></td></tr></table></figure>\n\n<p>show vlan 检测配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch#show vlan</span><br><span class=\"line\"></span><br><span class=\"line\">VLAN Name                             Status    Ports</span><br><span class=\"line\">---- -------------------------------- --------- -------------------------------</span><br><span class=\"line\">10   VLAN0010                         active    Fa0/1, Fa0/3</span><br><span class=\"line\">20   VLAN0020                         active    Fa0/2, Fa0/4</span><br></pre></td></tr></table></figure>\n\n<p>接下来配置trunk port，此时需要配置L2 SW的 f0/5 和 L3 SW的 f0/1</p>\n<p>配置L2 SW f0/5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch(config)#int f0/5</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk </span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to down</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/5, changed state to up</span><br></pre></td></tr></table></figure>\n\n<p>配置L3 SW f0/1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Switch(config)#int f0/1</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk</span><br><span class=\"line\">Command rejected: An interface whose trunk encapsulation is &quot;Auto&quot; can not be configured to &quot;trunk&quot; mode.</span><br><span class=\"line\"># 没有指定端口的VLAN封装类型</span><br><span class=\"line\">Switch(config-if)#switchport trunk encapsulation dot1q #指定为802.1Q封装</span><br><span class=\"line\">Switch(config-if)#switchport mode trunk #设置端口为Trunk Port</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#vlan 10</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#vlan 20</span><br><span class=\"line\">Switch(config-vlan)#exit</span><br><span class=\"line\">Switch(config)#int vlan 10</span><br><span class=\"line\">Switch(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface Vlan10, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan10, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(config-if)#ip address 192.168.10.254 255.255.255.0</span><br><span class=\"line\">Switch(config-if)#int vlan 20</span><br><span class=\"line\">Switch(config-if)#</span><br><span class=\"line\">%LINK-5-CHANGED: Interface Vlan20, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to up</span><br><span class=\"line\"></span><br><span class=\"line\">Switch(config-if)#ip address 192.168.20.254 255.255.255.0</span><br><span class=\"line\">Switch(config-if)#exit</span><br><span class=\"line\">Switch(config)#</span><br><span class=\"line\">Switch#</span><br><span class=\"line\">%SYS-5-CONFIG_I: Configured from console by console</span><br><span class=\"line\"></span><br><span class=\"line\">Switch#show ip route </span><br><span class=\"line\">Default gateway is not set</span><br><span class=\"line\"></span><br><span class=\"line\">Host               Gateway           Last Use    Total Uses  Interface</span><br><span class=\"line\">ICMP redirect cache is empty</span><br><span class=\"line\">\t</span><br><span class=\"line\">Switch#config t</span><br><span class=\"line\">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class=\"line\">Switch(config)#ip routing #开启路由</span><br><span class=\"line\">Switch(config)#exit</span><br><span class=\"line\">Switch#show ip route </span><br><span class=\"line\">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class=\"line\">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class=\"line\">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class=\"line\">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class=\"line\">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class=\"line\">       * - candidate default, U - per-user static route, o - ODR</span><br><span class=\"line\">       P - periodic downloaded static route</span><br><span class=\"line\"></span><br><span class=\"line\">Gateway of last resort is not set</span><br><span class=\"line\"></span><br><span class=\"line\">C    192.168.10.0/24 is directly connected, Vlan10</span><br><span class=\"line\">C    192.168.20.0/24 is directly connected, Vlan20</span><br></pre></td></tr></table></figure>\n\n<p>此时PC1 ping PC2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/文章/VLAN技术学习总结/image_2022-04-09_03-28-53.50wbrt7hwfg0.webp\" alt=\"image_2022-04-09_03-28-53\" style=\"zoom:50%;\" />\n\n<p>可以看到已经通了。</p>\n<h4 id=\"PC1-ping-PC2的数据包追踪流程图\"><a href=\"#PC1-ping-PC2的数据包追踪流程图\" class=\"headerlink\" title=\"PC1 ping PC2的数据包追踪流程图\"></a>PC1 ping PC2的数据包追踪流程图</h4><p><img src=\"https://cdn.jsdelivr.net/gh/yuhanOvo/image-hosting@master/%E6%96%87%E7%AB%A0/VLAN%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG_0965(20220409-035030).6amubcp68rs0.PNG\" alt=\"IMG_0965(20220409-035030)\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1mhhtcz00019icb0pkq1t23","category_id":"cl1mhhtd200049icb7x6ielyd","_id":"cl1mhhtd400099icb5lvu3w3t"},{"post_id":"cl1mhhtd100039icb1i384niy","category_id":"cl1mhhtd200049icb7x6ielyd","_id":"cl1mhhtd4000c9icbc20n5d23"}],"PostTag":[{"post_id":"cl1mhhtcz00019icb0pkq1t23","tag_id":"cl1mhhtd300059icbbg440pue","_id":"cl1mhhtd4000b9icb5zirhbsz"},{"post_id":"cl1mhhtcz00019icb0pkq1t23","tag_id":"cl1mhhtd300089icb3xhp31xj","_id":"cl1mhhtd4000d9icbbads235r"},{"post_id":"cl1mhhtd100039icb1i384niy","tag_id":"cl1mhhtd300059icbbg440pue","_id":"cl1mhhtd5000h9icbg0gv8luf"},{"post_id":"cl1mhhtd100039icb1i384niy","tag_id":"cl1mhhtd4000e9icbdwwegf1m","_id":"cl1mhhtd5000i9icbfiba3wsm"},{"post_id":"cl1mhhtd100039icb1i384niy","tag_id":"cl1mhhtd300089icb3xhp31xj","_id":"cl1mhhtd5000j9icb0a4t4uxt"},{"post_id":"cl1mhhtd100039icb1i384niy","tag_id":"cl1mhhtd5000g9icb1uovgt3y","_id":"cl1mhhtd5000k9icbg4av17jq"}],"Tag":[{"name":"linux","_id":"cl1mhhtd300059icbbg440pue"},{"name":"c","_id":"cl1mhhtd300089icb3xhp31xj"},{"name":"c++","_id":"cl1mhhtd4000e9icbdwwegf1m"},{"name":"makefile","_id":"cl1mhhtd5000g9icb1uovgt3y"}]}}